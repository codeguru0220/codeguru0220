{"ast":null,"code":"import { clamp, getDistances, getRandom } from \"tsparticles-engine\";\nexport function applyDistance(particle) {\n  const initialPosition = particle.initialPosition,\n        {\n    dx,\n    dy\n  } = getDistances(initialPosition, particle.position),\n        dxFixed = Math.abs(dx),\n        dyFixed = Math.abs(dy),\n        {\n    maxDistance\n  } = particle.retina,\n        hDistance = maxDistance.horizontal,\n        vDistance = maxDistance.vertical;\n\n  if (!hDistance && !vDistance) {\n    return;\n  }\n\n  if ((hDistance && dxFixed >= hDistance || vDistance && dyFixed >= vDistance) && !particle.misplaced) {\n    particle.misplaced = !!hDistance && dxFixed > hDistance || !!vDistance && dyFixed > vDistance;\n\n    if (hDistance) {\n      particle.velocity.x = particle.velocity.y / 2 - particle.velocity.x;\n    }\n\n    if (vDistance) {\n      particle.velocity.y = particle.velocity.x / 2 - particle.velocity.y;\n    }\n  } else if ((!hDistance || dxFixed < hDistance) && (!vDistance || dyFixed < vDistance) && particle.misplaced) {\n    particle.misplaced = false;\n  } else if (particle.misplaced) {\n    const pos = particle.position,\n          vel = particle.velocity;\n\n    if (hDistance && (pos.x < initialPosition.x && vel.x < 0 || pos.x > initialPosition.x && vel.x > 0)) {\n      vel.x *= -getRandom();\n    }\n\n    if (vDistance && (pos.y < initialPosition.y && vel.y < 0 || pos.y > initialPosition.y && vel.y > 0)) {\n      vel.y *= -getRandom();\n    }\n  }\n}\nexport function move(particle, moveOptions, moveSpeed, maxSpeed, moveDrift, delta) {\n  applyPath(particle, delta);\n  const gravityOptions = particle.gravity,\n        gravityFactor = gravityOptions?.enable && gravityOptions.inverse ? -1 : 1;\n\n  if (moveDrift && moveSpeed) {\n    particle.velocity.x += moveDrift * delta.factor / (60 * moveSpeed);\n  }\n\n  if (gravityOptions?.enable && moveSpeed) {\n    particle.velocity.y += gravityFactor * (gravityOptions.acceleration * delta.factor) / (60 * moveSpeed);\n  }\n\n  const decay = particle.moveDecay;\n  particle.velocity.multTo(decay);\n  const velocity = particle.velocity.mult(moveSpeed);\n\n  if (gravityOptions?.enable && maxSpeed > 0 && (!gravityOptions.inverse && velocity.y >= 0 && velocity.y >= maxSpeed || gravityOptions.inverse && velocity.y <= 0 && velocity.y <= -maxSpeed)) {\n    velocity.y = gravityFactor * maxSpeed;\n\n    if (moveSpeed) {\n      particle.velocity.y = velocity.y / moveSpeed;\n    }\n  }\n\n  const zIndexOptions = particle.options.zIndex,\n        zVelocityFactor = (1 - particle.zIndexFactor) ** zIndexOptions.velocityRate;\n  velocity.multTo(zVelocityFactor);\n  const {\n    position\n  } = particle;\n  position.addTo(velocity);\n\n  if (moveOptions.vibrate) {\n    position.x += Math.sin(position.x * Math.cos(position.y));\n    position.y += Math.cos(position.y * Math.sin(position.x));\n  }\n}\nexport function spin(particle, moveSpeed) {\n  const container = particle.container;\n\n  if (!particle.spin) {\n    return;\n  }\n\n  const updateFunc = {\n    x: particle.spin.direction === \"clockwise\" ? Math.cos : Math.sin,\n    y: particle.spin.direction === \"clockwise\" ? Math.sin : Math.cos\n  };\n  particle.position.x = particle.spin.center.x + particle.spin.radius * updateFunc.x(particle.spin.angle);\n  particle.position.y = particle.spin.center.y + particle.spin.radius * updateFunc.y(particle.spin.angle);\n  particle.spin.radius += particle.spin.acceleration;\n  const maxCanvasSize = Math.max(container.canvas.size.width, container.canvas.size.height);\n\n  if (particle.spin.radius > maxCanvasSize / 2) {\n    particle.spin.radius = maxCanvasSize / 2;\n    particle.spin.acceleration *= -1;\n  } else if (particle.spin.radius < 0) {\n    particle.spin.radius = 0;\n    particle.spin.acceleration *= -1;\n  }\n\n  particle.spin.angle += moveSpeed / 100 * (1 - particle.spin.radius / maxCanvasSize);\n}\nexport function applyPath(particle, delta) {\n  const particlesOptions = particle.options,\n        pathOptions = particlesOptions.move.path,\n        pathEnabled = pathOptions.enable;\n\n  if (!pathEnabled) {\n    return;\n  }\n\n  if (particle.lastPathTime <= particle.pathDelay) {\n    particle.lastPathTime += delta.value;\n    return;\n  }\n\n  const path = particle.pathGenerator?.generate(particle, delta);\n\n  if (path) {\n    particle.velocity.addTo(path);\n  }\n\n  if (pathOptions.clamp) {\n    particle.velocity.x = clamp(particle.velocity.x, -1, 1);\n    particle.velocity.y = clamp(particle.velocity.y, -1, 1);\n  }\n\n  particle.lastPathTime -= particle.pathDelay;\n}\nexport function getProximitySpeedFactor(particle) {\n  return particle.slow.inRange ? particle.slow.factor : 1;\n}","map":{"version":3,"sources":["D:/mitsukimiyagi-portfolio/node_modules/tsparticles-move-base/esm/Utils.js"],"names":["clamp","getDistances","getRandom","applyDistance","particle","initialPosition","dx","dy","position","dxFixed","Math","abs","dyFixed","maxDistance","retina","hDistance","horizontal","vDistance","vertical","misplaced","velocity","x","y","pos","vel","move","moveOptions","moveSpeed","maxSpeed","moveDrift","delta","applyPath","gravityOptions","gravity","gravityFactor","enable","inverse","factor","acceleration","decay","moveDecay","multTo","mult","zIndexOptions","options","zIndex","zVelocityFactor","zIndexFactor","velocityRate","addTo","vibrate","sin","cos","spin","container","updateFunc","direction","center","radius","angle","maxCanvasSize","max","canvas","size","width","height","particlesOptions","pathOptions","path","pathEnabled","lastPathTime","pathDelay","value","pathGenerator","generate","getProximitySpeedFactor","slow","inRange"],"mappings":"AAAA,SAASA,KAAT,EAAgBC,YAAhB,EAA8BC,SAA9B,QAAgD,oBAAhD;AACA,OAAO,SAASC,aAAT,CAAuBC,QAAvB,EAAiC;AACpC,QAAMC,eAAe,GAAGD,QAAQ,CAACC,eAAjC;AAAA,QAAkD;AAAEC,IAAAA,EAAF;AAAMC,IAAAA;AAAN,MAAaN,YAAY,CAACI,eAAD,EAAkBD,QAAQ,CAACI,QAA3B,CAA3E;AAAA,QAAiHC,OAAO,GAAGC,IAAI,CAACC,GAAL,CAASL,EAAT,CAA3H;AAAA,QAAyIM,OAAO,GAAGF,IAAI,CAACC,GAAL,CAASJ,EAAT,CAAnJ;AAAA,QAAiK;AAAEM,IAAAA;AAAF,MAAkBT,QAAQ,CAACU,MAA5L;AAAA,QAAoMC,SAAS,GAAGF,WAAW,CAACG,UAA5N;AAAA,QAAwOC,SAAS,GAAGJ,WAAW,CAACK,QAAhQ;;AACA,MAAI,CAACH,SAAD,IAAc,CAACE,SAAnB,EAA8B;AAC1B;AACH;;AACD,MAAI,CAAEF,SAAS,IAAIN,OAAO,IAAIM,SAAzB,IAAwCE,SAAS,IAAIL,OAAO,IAAIK,SAAjE,KAAgF,CAACb,QAAQ,CAACe,SAA9F,EAAyG;AACrGf,IAAAA,QAAQ,CAACe,SAAT,GAAsB,CAAC,CAACJ,SAAF,IAAeN,OAAO,GAAGM,SAA1B,IAAyC,CAAC,CAACE,SAAF,IAAeL,OAAO,GAAGK,SAAvF;;AACA,QAAIF,SAAJ,EAAe;AACXX,MAAAA,QAAQ,CAACgB,QAAT,CAAkBC,CAAlB,GAAsBjB,QAAQ,CAACgB,QAAT,CAAkBE,CAAlB,GAAsB,CAAtB,GAA0BlB,QAAQ,CAACgB,QAAT,CAAkBC,CAAlE;AACH;;AACD,QAAIJ,SAAJ,EAAe;AACXb,MAAAA,QAAQ,CAACgB,QAAT,CAAkBE,CAAlB,GAAsBlB,QAAQ,CAACgB,QAAT,CAAkBC,CAAlB,GAAsB,CAAtB,GAA0BjB,QAAQ,CAACgB,QAAT,CAAkBE,CAAlE;AACH;AACJ,GARD,MASK,IAAI,CAAC,CAACP,SAAD,IAAcN,OAAO,GAAGM,SAAzB,MAAwC,CAACE,SAAD,IAAcL,OAAO,GAAGK,SAAhE,KAA8Eb,QAAQ,CAACe,SAA3F,EAAsG;AACvGf,IAAAA,QAAQ,CAACe,SAAT,GAAqB,KAArB;AACH,GAFI,MAGA,IAAIf,QAAQ,CAACe,SAAb,EAAwB;AACzB,UAAMI,GAAG,GAAGnB,QAAQ,CAACI,QAArB;AAAA,UAA+BgB,GAAG,GAAGpB,QAAQ,CAACgB,QAA9C;;AACA,QAAIL,SAAS,KAAMQ,GAAG,CAACF,CAAJ,GAAQhB,eAAe,CAACgB,CAAxB,IAA6BG,GAAG,CAACH,CAAJ,GAAQ,CAAtC,IAA6CE,GAAG,CAACF,CAAJ,GAAQhB,eAAe,CAACgB,CAAxB,IAA6BG,GAAG,CAACH,CAAJ,GAAQ,CAAvF,CAAb,EAAyG;AACrGG,MAAAA,GAAG,CAACH,CAAJ,IAAS,CAACnB,SAAS,EAAnB;AACH;;AACD,QAAIe,SAAS,KAAMM,GAAG,CAACD,CAAJ,GAAQjB,eAAe,CAACiB,CAAxB,IAA6BE,GAAG,CAACF,CAAJ,GAAQ,CAAtC,IAA6CC,GAAG,CAACD,CAAJ,GAAQjB,eAAe,CAACiB,CAAxB,IAA6BE,GAAG,CAACF,CAAJ,GAAQ,CAAvF,CAAb,EAAyG;AACrGE,MAAAA,GAAG,CAACF,CAAJ,IAAS,CAACpB,SAAS,EAAnB;AACH;AACJ;AACJ;AACD,OAAO,SAASuB,IAAT,CAAcrB,QAAd,EAAwBsB,WAAxB,EAAqCC,SAArC,EAAgDC,QAAhD,EAA0DC,SAA1D,EAAqEC,KAArE,EAA4E;AAC/EC,EAAAA,SAAS,CAAC3B,QAAD,EAAW0B,KAAX,CAAT;AACA,QAAME,cAAc,GAAG5B,QAAQ,CAAC6B,OAAhC;AAAA,QAAyCC,aAAa,GAAGF,cAAc,EAAEG,MAAhB,IAA0BH,cAAc,CAACI,OAAzC,GAAmD,CAAC,CAApD,GAAwD,CAAjH;;AACA,MAAIP,SAAS,IAAIF,SAAjB,EAA4B;AACxBvB,IAAAA,QAAQ,CAACgB,QAAT,CAAkBC,CAAlB,IAAwBQ,SAAS,GAAGC,KAAK,CAACO,MAAnB,IAA8B,KAAKV,SAAnC,CAAvB;AACH;;AACD,MAAIK,cAAc,EAAEG,MAAhB,IAA0BR,SAA9B,EAAyC;AACrCvB,IAAAA,QAAQ,CAACgB,QAAT,CAAkBE,CAAlB,IAAwBY,aAAa,IAAIF,cAAc,CAACM,YAAf,GAA8BR,KAAK,CAACO,MAAxC,CAAd,IAAkE,KAAKV,SAAvE,CAAvB;AACH;;AACD,QAAMY,KAAK,GAAGnC,QAAQ,CAACoC,SAAvB;AACApC,EAAAA,QAAQ,CAACgB,QAAT,CAAkBqB,MAAlB,CAAyBF,KAAzB;AACA,QAAMnB,QAAQ,GAAGhB,QAAQ,CAACgB,QAAT,CAAkBsB,IAAlB,CAAuBf,SAAvB,CAAjB;;AACA,MAAIK,cAAc,EAAEG,MAAhB,IACAP,QAAQ,GAAG,CADX,KAEE,CAACI,cAAc,CAACI,OAAhB,IAA2BhB,QAAQ,CAACE,CAAT,IAAc,CAAzC,IAA8CF,QAAQ,CAACE,CAAT,IAAcM,QAA7D,IACII,cAAc,CAACI,OAAf,IAA0BhB,QAAQ,CAACE,CAAT,IAAc,CAAxC,IAA6CF,QAAQ,CAACE,CAAT,IAAc,CAACM,QAHjE,CAAJ,EAGiF;AAC7ER,IAAAA,QAAQ,CAACE,CAAT,GAAaY,aAAa,GAAGN,QAA7B;;AACA,QAAID,SAAJ,EAAe;AACXvB,MAAAA,QAAQ,CAACgB,QAAT,CAAkBE,CAAlB,GAAsBF,QAAQ,CAACE,CAAT,GAAaK,SAAnC;AACH;AACJ;;AACD,QAAMgB,aAAa,GAAGvC,QAAQ,CAACwC,OAAT,CAAiBC,MAAvC;AAAA,QAA+CC,eAAe,GAAG,CAAC,IAAI1C,QAAQ,CAAC2C,YAAd,KAA+BJ,aAAa,CAACK,YAA9G;AACA5B,EAAAA,QAAQ,CAACqB,MAAT,CAAgBK,eAAhB;AACA,QAAM;AAAEtC,IAAAA;AAAF,MAAeJ,QAArB;AACAI,EAAAA,QAAQ,CAACyC,KAAT,CAAe7B,QAAf;;AACA,MAAIM,WAAW,CAACwB,OAAhB,EAAyB;AACrB1C,IAAAA,QAAQ,CAACa,CAAT,IAAcX,IAAI,CAACyC,GAAL,CAAS3C,QAAQ,CAACa,CAAT,GAAaX,IAAI,CAAC0C,GAAL,CAAS5C,QAAQ,CAACc,CAAlB,CAAtB,CAAd;AACAd,IAAAA,QAAQ,CAACc,CAAT,IAAcZ,IAAI,CAAC0C,GAAL,CAAS5C,QAAQ,CAACc,CAAT,GAAaZ,IAAI,CAACyC,GAAL,CAAS3C,QAAQ,CAACa,CAAlB,CAAtB,CAAd;AACH;AACJ;AACD,OAAO,SAASgC,IAAT,CAAcjD,QAAd,EAAwBuB,SAAxB,EAAmC;AACtC,QAAM2B,SAAS,GAAGlD,QAAQ,CAACkD,SAA3B;;AACA,MAAI,CAAClD,QAAQ,CAACiD,IAAd,EAAoB;AAChB;AACH;;AACD,QAAME,UAAU,GAAG;AACflC,IAAAA,CAAC,EAAEjB,QAAQ,CAACiD,IAAT,CAAcG,SAAd,KAA4B,WAA5B,GAA0C9C,IAAI,CAAC0C,GAA/C,GAAqD1C,IAAI,CAACyC,GAD9C;AAEf7B,IAAAA,CAAC,EAAElB,QAAQ,CAACiD,IAAT,CAAcG,SAAd,KAA4B,WAA5B,GAA0C9C,IAAI,CAACyC,GAA/C,GAAqDzC,IAAI,CAAC0C;AAF9C,GAAnB;AAIAhD,EAAAA,QAAQ,CAACI,QAAT,CAAkBa,CAAlB,GAAsBjB,QAAQ,CAACiD,IAAT,CAAcI,MAAd,CAAqBpC,CAArB,GAAyBjB,QAAQ,CAACiD,IAAT,CAAcK,MAAd,GAAuBH,UAAU,CAAClC,CAAX,CAAajB,QAAQ,CAACiD,IAAT,CAAcM,KAA3B,CAAtE;AACAvD,EAAAA,QAAQ,CAACI,QAAT,CAAkBc,CAAlB,GAAsBlB,QAAQ,CAACiD,IAAT,CAAcI,MAAd,CAAqBnC,CAArB,GAAyBlB,QAAQ,CAACiD,IAAT,CAAcK,MAAd,GAAuBH,UAAU,CAACjC,CAAX,CAAalB,QAAQ,CAACiD,IAAT,CAAcM,KAA3B,CAAtE;AACAvD,EAAAA,QAAQ,CAACiD,IAAT,CAAcK,MAAd,IAAwBtD,QAAQ,CAACiD,IAAT,CAAcf,YAAtC;AACA,QAAMsB,aAAa,GAAGlD,IAAI,CAACmD,GAAL,CAASP,SAAS,CAACQ,MAAV,CAAiBC,IAAjB,CAAsBC,KAA/B,EAAsCV,SAAS,CAACQ,MAAV,CAAiBC,IAAjB,CAAsBE,MAA5D,CAAtB;;AACA,MAAI7D,QAAQ,CAACiD,IAAT,CAAcK,MAAd,GAAuBE,aAAa,GAAG,CAA3C,EAA8C;AAC1CxD,IAAAA,QAAQ,CAACiD,IAAT,CAAcK,MAAd,GAAuBE,aAAa,GAAG,CAAvC;AACAxD,IAAAA,QAAQ,CAACiD,IAAT,CAAcf,YAAd,IAA8B,CAAC,CAA/B;AACH,GAHD,MAIK,IAAIlC,QAAQ,CAACiD,IAAT,CAAcK,MAAd,GAAuB,CAA3B,EAA8B;AAC/BtD,IAAAA,QAAQ,CAACiD,IAAT,CAAcK,MAAd,GAAuB,CAAvB;AACAtD,IAAAA,QAAQ,CAACiD,IAAT,CAAcf,YAAd,IAA8B,CAAC,CAA/B;AACH;;AACDlC,EAAAA,QAAQ,CAACiD,IAAT,CAAcM,KAAd,IAAwBhC,SAAS,GAAG,GAAb,IAAqB,IAAIvB,QAAQ,CAACiD,IAAT,CAAcK,MAAd,GAAuBE,aAAhD,CAAvB;AACH;AACD,OAAO,SAAS7B,SAAT,CAAmB3B,QAAnB,EAA6B0B,KAA7B,EAAoC;AACvC,QAAMoC,gBAAgB,GAAG9D,QAAQ,CAACwC,OAAlC;AAAA,QAA2CuB,WAAW,GAAGD,gBAAgB,CAACzC,IAAjB,CAAsB2C,IAA/E;AAAA,QAAqFC,WAAW,GAAGF,WAAW,CAAChC,MAA/G;;AACA,MAAI,CAACkC,WAAL,EAAkB;AACd;AACH;;AACD,MAAIjE,QAAQ,CAACkE,YAAT,IAAyBlE,QAAQ,CAACmE,SAAtC,EAAiD;AAC7CnE,IAAAA,QAAQ,CAACkE,YAAT,IAAyBxC,KAAK,CAAC0C,KAA/B;AACA;AACH;;AACD,QAAMJ,IAAI,GAAGhE,QAAQ,CAACqE,aAAT,EAAwBC,QAAxB,CAAiCtE,QAAjC,EAA2C0B,KAA3C,CAAb;;AACA,MAAIsC,IAAJ,EAAU;AACNhE,IAAAA,QAAQ,CAACgB,QAAT,CAAkB6B,KAAlB,CAAwBmB,IAAxB;AACH;;AACD,MAAID,WAAW,CAACnE,KAAhB,EAAuB;AACnBI,IAAAA,QAAQ,CAACgB,QAAT,CAAkBC,CAAlB,GAAsBrB,KAAK,CAACI,QAAQ,CAACgB,QAAT,CAAkBC,CAAnB,EAAsB,CAAC,CAAvB,EAA0B,CAA1B,CAA3B;AACAjB,IAAAA,QAAQ,CAACgB,QAAT,CAAkBE,CAAlB,GAAsBtB,KAAK,CAACI,QAAQ,CAACgB,QAAT,CAAkBE,CAAnB,EAAsB,CAAC,CAAvB,EAA0B,CAA1B,CAA3B;AACH;;AACDlB,EAAAA,QAAQ,CAACkE,YAAT,IAAyBlE,QAAQ,CAACmE,SAAlC;AACH;AACD,OAAO,SAASI,uBAAT,CAAiCvE,QAAjC,EAA2C;AAC9C,SAAOA,QAAQ,CAACwE,IAAT,CAAcC,OAAd,GAAwBzE,QAAQ,CAACwE,IAAT,CAAcvC,MAAtC,GAA+C,CAAtD;AACH","sourcesContent":["import { clamp, getDistances, getRandom, } from \"tsparticles-engine\";\nexport function applyDistance(particle) {\n    const initialPosition = particle.initialPosition, { dx, dy } = getDistances(initialPosition, particle.position), dxFixed = Math.abs(dx), dyFixed = Math.abs(dy), { maxDistance } = particle.retina, hDistance = maxDistance.horizontal, vDistance = maxDistance.vertical;\n    if (!hDistance && !vDistance) {\n        return;\n    }\n    if (((hDistance && dxFixed >= hDistance) || (vDistance && dyFixed >= vDistance)) && !particle.misplaced) {\n        particle.misplaced = (!!hDistance && dxFixed > hDistance) || (!!vDistance && dyFixed > vDistance);\n        if (hDistance) {\n            particle.velocity.x = particle.velocity.y / 2 - particle.velocity.x;\n        }\n        if (vDistance) {\n            particle.velocity.y = particle.velocity.x / 2 - particle.velocity.y;\n        }\n    }\n    else if ((!hDistance || dxFixed < hDistance) && (!vDistance || dyFixed < vDistance) && particle.misplaced) {\n        particle.misplaced = false;\n    }\n    else if (particle.misplaced) {\n        const pos = particle.position, vel = particle.velocity;\n        if (hDistance && ((pos.x < initialPosition.x && vel.x < 0) || (pos.x > initialPosition.x && vel.x > 0))) {\n            vel.x *= -getRandom();\n        }\n        if (vDistance && ((pos.y < initialPosition.y && vel.y < 0) || (pos.y > initialPosition.y && vel.y > 0))) {\n            vel.y *= -getRandom();\n        }\n    }\n}\nexport function move(particle, moveOptions, moveSpeed, maxSpeed, moveDrift, delta) {\n    applyPath(particle, delta);\n    const gravityOptions = particle.gravity, gravityFactor = gravityOptions?.enable && gravityOptions.inverse ? -1 : 1;\n    if (moveDrift && moveSpeed) {\n        particle.velocity.x += (moveDrift * delta.factor) / (60 * moveSpeed);\n    }\n    if (gravityOptions?.enable && moveSpeed) {\n        particle.velocity.y += (gravityFactor * (gravityOptions.acceleration * delta.factor)) / (60 * moveSpeed);\n    }\n    const decay = particle.moveDecay;\n    particle.velocity.multTo(decay);\n    const velocity = particle.velocity.mult(moveSpeed);\n    if (gravityOptions?.enable &&\n        maxSpeed > 0 &&\n        ((!gravityOptions.inverse && velocity.y >= 0 && velocity.y >= maxSpeed) ||\n            (gravityOptions.inverse && velocity.y <= 0 && velocity.y <= -maxSpeed))) {\n        velocity.y = gravityFactor * maxSpeed;\n        if (moveSpeed) {\n            particle.velocity.y = velocity.y / moveSpeed;\n        }\n    }\n    const zIndexOptions = particle.options.zIndex, zVelocityFactor = (1 - particle.zIndexFactor) ** zIndexOptions.velocityRate;\n    velocity.multTo(zVelocityFactor);\n    const { position } = particle;\n    position.addTo(velocity);\n    if (moveOptions.vibrate) {\n        position.x += Math.sin(position.x * Math.cos(position.y));\n        position.y += Math.cos(position.y * Math.sin(position.x));\n    }\n}\nexport function spin(particle, moveSpeed) {\n    const container = particle.container;\n    if (!particle.spin) {\n        return;\n    }\n    const updateFunc = {\n        x: particle.spin.direction === \"clockwise\" ? Math.cos : Math.sin,\n        y: particle.spin.direction === \"clockwise\" ? Math.sin : Math.cos,\n    };\n    particle.position.x = particle.spin.center.x + particle.spin.radius * updateFunc.x(particle.spin.angle);\n    particle.position.y = particle.spin.center.y + particle.spin.radius * updateFunc.y(particle.spin.angle);\n    particle.spin.radius += particle.spin.acceleration;\n    const maxCanvasSize = Math.max(container.canvas.size.width, container.canvas.size.height);\n    if (particle.spin.radius > maxCanvasSize / 2) {\n        particle.spin.radius = maxCanvasSize / 2;\n        particle.spin.acceleration *= -1;\n    }\n    else if (particle.spin.radius < 0) {\n        particle.spin.radius = 0;\n        particle.spin.acceleration *= -1;\n    }\n    particle.spin.angle += (moveSpeed / 100) * (1 - particle.spin.radius / maxCanvasSize);\n}\nexport function applyPath(particle, delta) {\n    const particlesOptions = particle.options, pathOptions = particlesOptions.move.path, pathEnabled = pathOptions.enable;\n    if (!pathEnabled) {\n        return;\n    }\n    if (particle.lastPathTime <= particle.pathDelay) {\n        particle.lastPathTime += delta.value;\n        return;\n    }\n    const path = particle.pathGenerator?.generate(particle, delta);\n    if (path) {\n        particle.velocity.addTo(path);\n    }\n    if (pathOptions.clamp) {\n        particle.velocity.x = clamp(particle.velocity.x, -1, 1);\n        particle.velocity.y = clamp(particle.velocity.y, -1, 1);\n    }\n    particle.lastPathTime -= particle.pathDelay;\n}\nexport function getProximitySpeedFactor(particle) {\n    return particle.slow.inRange ? particle.slow.factor : 1;\n}\n"]},"metadata":{},"sourceType":"module"}