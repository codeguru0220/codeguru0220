{"ast":null,"code":"import { Circle, ExternalInteractorBase, Rectangle, Vector, calculateBounds, circleBounce, circleBounceDataFromParticle, divModeExecute, isDivModeEnabled, isInArray, mouseMoveEvent, rectBounce } from \"tsparticles-engine\";\nimport { Bounce } from \"./Options/Classes/Bounce\";\nexport class Bouncer extends ExternalInteractorBase {\n  constructor(container) {\n    super(container);\n\n    this._processBounce = (position, radius, area) => {\n      const query = this.container.particles.quadTree.query(area, p => this.isEnabled(p));\n\n      for (const particle of query) {\n        if (area instanceof Circle) {\n          circleBounce(circleBounceDataFromParticle(particle), {\n            position,\n            radius,\n            mass: radius ** 2 * Math.PI / 2,\n            velocity: Vector.origin,\n            factor: Vector.origin\n          });\n        } else if (area instanceof Rectangle) {\n          rectBounce(particle, calculateBounds(position, radius));\n        }\n      }\n    };\n\n    this._processMouseBounce = () => {\n      const container = this.container,\n            pxRatio = container.retina.pixelRatio,\n            tolerance = 10 * pxRatio,\n            mousePos = container.interactivity.mouse.position,\n            radius = container.retina.bounceModeDistance;\n\n      if (!radius || radius < 0 || !mousePos) {\n        return;\n      }\n\n      this._processBounce(mousePos, radius, new Circle(mousePos.x, mousePos.y, radius + tolerance));\n    };\n\n    this._singleSelectorBounce = (selector, div) => {\n      const container = this.container,\n            query = document.querySelectorAll(selector);\n\n      if (!query.length) {\n        return;\n      }\n\n      query.forEach(item => {\n        const elem = item,\n              pxRatio = container.retina.pixelRatio,\n              pos = {\n          x: (elem.offsetLeft + elem.offsetWidth / 2) * pxRatio,\n          y: (elem.offsetTop + elem.offsetHeight / 2) * pxRatio\n        },\n              radius = elem.offsetWidth / 2 * pxRatio,\n              tolerance = 10 * pxRatio,\n              area = div.type === \"circle\" ? new Circle(pos.x, pos.y, radius + tolerance) : new Rectangle(elem.offsetLeft * pxRatio - tolerance, elem.offsetTop * pxRatio - tolerance, elem.offsetWidth * pxRatio + tolerance * 2, elem.offsetHeight * pxRatio + tolerance * 2);\n\n        this._processBounce(pos, radius, area);\n      });\n    };\n  }\n\n  clear() {}\n\n  init() {\n    const container = this.container,\n          bounce = container.actualOptions.interactivity.modes.bounce;\n\n    if (!bounce) {\n      return;\n    }\n\n    container.retina.bounceModeDistance = bounce.distance * container.retina.pixelRatio;\n  }\n\n  async interact() {\n    const container = this.container,\n          options = container.actualOptions,\n          events = options.interactivity.events,\n          mouseMoveStatus = container.interactivity.status === mouseMoveEvent,\n          hoverEnabled = events.onHover.enable,\n          hoverMode = events.onHover.mode,\n          divs = events.onDiv;\n\n    if (mouseMoveStatus && hoverEnabled && isInArray(\"bounce\", hoverMode)) {\n      this._processMouseBounce();\n    } else {\n      divModeExecute(\"bounce\", divs, (selector, div) => this._singleSelectorBounce(selector, div));\n    }\n  }\n\n  isEnabled(particle) {\n    const container = this.container,\n          options = container.actualOptions,\n          mouse = container.interactivity.mouse,\n          events = (particle?.interactivity ?? options.interactivity).events,\n          divs = events.onDiv;\n    return mouse.position && events.onHover.enable && isInArray(\"bounce\", events.onHover.mode) || isDivModeEnabled(\"bounce\", divs);\n  }\n\n  loadModeOptions(options) {\n    if (!options.bounce) {\n      options.bounce = new Bounce();\n    }\n\n    for (var _len = arguments.length, sources = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      sources[_key - 1] = arguments[_key];\n    }\n\n    for (const source of sources) {\n      options.bounce.load(source?.bounce);\n    }\n  }\n\n  reset() {}\n\n}","map":{"version":3,"sources":["D:/mitsukimiyagi-portfolio/node_modules/tsparticles-interaction-external-bounce/esm/Bouncer.js"],"names":["Circle","ExternalInteractorBase","Rectangle","Vector","calculateBounds","circleBounce","circleBounceDataFromParticle","divModeExecute","isDivModeEnabled","isInArray","mouseMoveEvent","rectBounce","Bounce","Bouncer","constructor","container","_processBounce","position","radius","area","query","particles","quadTree","p","isEnabled","particle","mass","Math","PI","velocity","origin","factor","_processMouseBounce","pxRatio","retina","pixelRatio","tolerance","mousePos","interactivity","mouse","bounceModeDistance","x","y","_singleSelectorBounce","selector","div","document","querySelectorAll","length","forEach","item","elem","pos","offsetLeft","offsetWidth","offsetTop","offsetHeight","type","clear","init","bounce","actualOptions","modes","distance","interact","options","events","mouseMoveStatus","status","hoverEnabled","onHover","enable","hoverMode","mode","divs","onDiv","loadModeOptions","sources","source","load","reset"],"mappings":"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","sourcesContent":["import { Circle, ExternalInteractorBase, Rectangle, Vector, calculateBounds, circleBounce, circleBounceDataFromParticle, divModeExecute, isDivModeEnabled, isInArray, mouseMoveEvent, rectBounce, } from \"tsparticles-engine\";\nimport { Bounce } from \"./Options/Classes/Bounce\";\nexport class Bouncer extends ExternalInteractorBase {\n    constructor(container) {\n        super(container);\n        this._processBounce = (position, radius, area) => {\n            const query = this.container.particles.quadTree.query(area, (p) => this.isEnabled(p));\n            for (const particle of query) {\n                if (area instanceof Circle) {\n                    circleBounce(circleBounceDataFromParticle(particle), {\n                        position,\n                        radius,\n                        mass: (radius ** 2 * Math.PI) / 2,\n                        velocity: Vector.origin,\n                        factor: Vector.origin,\n                    });\n                }\n                else if (area instanceof Rectangle) {\n                    rectBounce(particle, calculateBounds(position, radius));\n                }\n            }\n        };\n        this._processMouseBounce = () => {\n            const container = this.container, pxRatio = container.retina.pixelRatio, tolerance = 10 * pxRatio, mousePos = container.interactivity.mouse.position, radius = container.retina.bounceModeDistance;\n            if (!radius || radius < 0 || !mousePos) {\n                return;\n            }\n            this._processBounce(mousePos, radius, new Circle(mousePos.x, mousePos.y, radius + tolerance));\n        };\n        this._singleSelectorBounce = (selector, div) => {\n            const container = this.container, query = document.querySelectorAll(selector);\n            if (!query.length) {\n                return;\n            }\n            query.forEach((item) => {\n                const elem = item, pxRatio = container.retina.pixelRatio, pos = {\n                    x: (elem.offsetLeft + elem.offsetWidth / 2) * pxRatio,\n                    y: (elem.offsetTop + elem.offsetHeight / 2) * pxRatio,\n                }, radius = (elem.offsetWidth / 2) * pxRatio, tolerance = 10 * pxRatio, area = div.type === \"circle\"\n                    ? new Circle(pos.x, pos.y, radius + tolerance)\n                    : new Rectangle(elem.offsetLeft * pxRatio - tolerance, elem.offsetTop * pxRatio - tolerance, elem.offsetWidth * pxRatio + tolerance * 2, elem.offsetHeight * pxRatio + tolerance * 2);\n                this._processBounce(pos, radius, area);\n            });\n        };\n    }\n    clear() {\n    }\n    init() {\n        const container = this.container, bounce = container.actualOptions.interactivity.modes.bounce;\n        if (!bounce) {\n            return;\n        }\n        container.retina.bounceModeDistance = bounce.distance * container.retina.pixelRatio;\n    }\n    async interact() {\n        const container = this.container, options = container.actualOptions, events = options.interactivity.events, mouseMoveStatus = container.interactivity.status === mouseMoveEvent, hoverEnabled = events.onHover.enable, hoverMode = events.onHover.mode, divs = events.onDiv;\n        if (mouseMoveStatus && hoverEnabled && isInArray(\"bounce\", hoverMode)) {\n            this._processMouseBounce();\n        }\n        else {\n            divModeExecute(\"bounce\", divs, (selector, div) => this._singleSelectorBounce(selector, div));\n        }\n    }\n    isEnabled(particle) {\n        const container = this.container, options = container.actualOptions, mouse = container.interactivity.mouse, events = (particle?.interactivity ?? options.interactivity).events, divs = events.onDiv;\n        return ((mouse.position && events.onHover.enable && isInArray(\"bounce\", events.onHover.mode)) ||\n            isDivModeEnabled(\"bounce\", divs));\n    }\n    loadModeOptions(options, ...sources) {\n        if (!options.bounce) {\n            options.bounce = new Bounce();\n        }\n        for (const source of sources) {\n            options.bounce.load(source?.bounce);\n        }\n    }\n    reset() {\n    }\n}\n"]},"metadata":{},"sourceType":"module"}