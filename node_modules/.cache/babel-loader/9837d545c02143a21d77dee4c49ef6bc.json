{"ast":null,"code":"import { calcExactPositionOrRandomFromSize, clamp, getDistance, getParticleBaseVelocity, getParticleDirectionAngle, getRandom, getRangeValue, getValue, randomInRange, setRangeValue } from \"../Utils/NumberUtils\";\nimport { deepExtend, getPosition, initParticleNumericAnimationValue, isInArray, itemFromSingleOrMultiple } from \"../Utils/Utils\";\nimport { getHslFromAnimation, rangeColorToRgb } from \"../Utils/ColorUtils\";\nimport { Interactivity } from \"../Options/Classes/Interactivity/Interactivity\";\nimport { Vector } from \"./Utils/Vector\";\nimport { Vector3d } from \"./Utils/Vector3d\";\nimport { alterHsl } from \"../Utils/CanvasUtils\";\nimport { errorPrefix } from \"./Utils/Constants\";\nimport { loadParticlesOptions } from \"../Utils/OptionsUtils\";\n\nconst fixOutMode = data => {\n  if (!isInArray(data.outMode, data.checkModes)) {\n    return;\n  }\n\n  const diameter = data.radius * 2;\n\n  if (data.coord > data.maxCoord - diameter) {\n    data.setCb(-data.radius);\n  } else if (data.coord < diameter) {\n    data.setCb(data.radius);\n  }\n};\n\nexport class Particle {\n  constructor(engine, id, container, position, overrideOptions, group) {\n    var _this = this;\n\n    this.container = container;\n\n    this._calcPosition = function (container, position, zIndex) {\n      let tryCount = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n\n      for (const [, plugin] of container.plugins) {\n        const pluginPos = plugin.particlePosition !== undefined ? plugin.particlePosition(position, _this) : undefined;\n\n        if (pluginPos) {\n          return Vector3d.create(pluginPos.x, pluginPos.y, zIndex);\n        }\n      }\n\n      const canvasSize = container.canvas.size,\n            exactPosition = calcExactPositionOrRandomFromSize({\n        size: canvasSize,\n        position: position\n      }),\n            pos = Vector3d.create(exactPosition.x, exactPosition.y, zIndex),\n            radius = _this.getRadius(),\n            outModes = _this.options.move.outModes,\n            fixHorizontal = outMode => {\n        fixOutMode({\n          outMode,\n          checkModes: [\"bounce\", \"bounce-horizontal\"],\n          coord: pos.x,\n          maxCoord: container.canvas.size.width,\n          setCb: value => pos.x += value,\n          radius\n        });\n      },\n            fixVertical = outMode => {\n        fixOutMode({\n          outMode,\n          checkModes: [\"bounce\", \"bounce-vertical\"],\n          coord: pos.y,\n          maxCoord: container.canvas.size.height,\n          setCb: value => pos.y += value,\n          radius\n        });\n      };\n\n      fixHorizontal(outModes.left ?? outModes.default);\n      fixHorizontal(outModes.right ?? outModes.default);\n      fixVertical(outModes.top ?? outModes.default);\n      fixVertical(outModes.bottom ?? outModes.default);\n\n      if (_this._checkOverlap(pos, tryCount)) {\n        return _this._calcPosition(container, undefined, zIndex, tryCount + 1);\n      }\n\n      return pos;\n    };\n\n    this._calculateVelocity = () => {\n      const baseVelocity = getParticleBaseVelocity(this.direction),\n            res = baseVelocity.copy(),\n            moveOptions = this.options.move;\n\n      if (moveOptions.direction === \"inside\" || moveOptions.direction === \"outside\") {\n        return res;\n      }\n\n      const rad = Math.PI / 180 * getRangeValue(moveOptions.angle.value),\n            radOffset = Math.PI / 180 * getRangeValue(moveOptions.angle.offset),\n            range = {\n        left: radOffset - rad / 2,\n        right: radOffset + rad / 2\n      };\n\n      if (!moveOptions.straight) {\n        res.angle += randomInRange(setRangeValue(range.left, range.right));\n      }\n\n      if (moveOptions.random && typeof moveOptions.speed === \"number\") {\n        res.length *= getRandom();\n      }\n\n      return res;\n    };\n\n    this._checkOverlap = function (pos) {\n      let tryCount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n      const collisionsOptions = _this.options.collisions,\n            radius = _this.getRadius();\n\n      if (!collisionsOptions.enable) {\n        return false;\n      }\n\n      const overlapOptions = collisionsOptions.overlap;\n\n      if (overlapOptions.enable) {\n        return false;\n      }\n\n      const retries = overlapOptions.retries;\n\n      if (retries >= 0 && tryCount > retries) {\n        throw new Error(`${errorPrefix} particle is overlapping and can't be placed`);\n      }\n\n      return !!_this.container.particles.find(particle => getDistance(pos, particle.position) < radius + particle.getRadius());\n    };\n\n    this._getRollColor = color => {\n      if (!color || !this.roll || !this.backColor && !this.roll.alter) {\n        return color;\n      }\n\n      const backFactor = this.roll.horizontal && this.roll.vertical ? 2 : 1,\n            backSum = this.roll.horizontal ? Math.PI / 2 : 0,\n            rolled = Math.floor(((this.roll.angle ?? 0) + backSum) / (Math.PI / backFactor)) % 2;\n\n      if (!rolled) {\n        return color;\n      }\n\n      if (this.backColor) {\n        return this.backColor;\n      }\n\n      if (this.roll.alter) {\n        return alterHsl(color, this.roll.alter.type, this.roll.alter.value);\n      }\n\n      return color;\n    };\n\n    this._initPosition = position => {\n      const container = this.container,\n            zIndexValue = getRangeValue(this.options.zIndex.value);\n      this.position = this._calcPosition(container, position, clamp(zIndexValue, 0, container.zLayers));\n      this.initialPosition = this.position.copy();\n      const canvasSize = container.canvas.size;\n      this.moveCenter = { ...getPosition(this.options.move.center, canvasSize),\n        radius: this.options.move.center.radius ?? 0,\n        mode: this.options.move.center.mode ?? \"percent\"\n      };\n      this.direction = getParticleDirectionAngle(this.options.move.direction, this.position, this.moveCenter);\n\n      switch (this.options.move.direction) {\n        case \"inside\":\n          this.outType = \"inside\";\n          break;\n\n        case \"outside\":\n          this.outType = \"outside\";\n          break;\n      }\n\n      this.offset = Vector.origin;\n    };\n\n    this._loadShapeData = (shapeOptions, reduceDuplicates) => {\n      const shapeData = shapeOptions.options[this.shape];\n\n      if (!shapeData) {\n        return;\n      }\n\n      return deepExtend({\n        close: shapeOptions.close,\n        fill: shapeOptions.fill\n      }, itemFromSingleOrMultiple(shapeData, this.id, reduceDuplicates));\n    };\n\n    this._engine = engine;\n    this.init(id, position, overrideOptions, group);\n  }\n\n  destroy(override) {\n    if (this.unbreakable || this.destroyed) {\n      return;\n    }\n\n    this.destroyed = true;\n    this.bubble.inRange = false;\n    this.slow.inRange = false;\n    const container = this.container,\n          pathGenerator = this.pathGenerator;\n\n    for (const [, plugin] of container.plugins) {\n      if (plugin.particleDestroyed) {\n        plugin.particleDestroyed(this, override);\n      }\n    }\n\n    for (const updater of container.particles.updaters) {\n      if (updater.particleDestroyed) {\n        updater.particleDestroyed(this, override);\n      }\n    }\n\n    if (pathGenerator) {\n      pathGenerator.reset(this);\n    }\n  }\n\n  draw(delta) {\n    const container = this.container;\n\n    for (const [, plugin] of container.plugins) {\n      container.canvas.drawParticlePlugin(plugin, this, delta);\n    }\n\n    container.canvas.drawParticle(this, delta);\n  }\n\n  getFillColor() {\n    return this._getRollColor(this.bubble.color ?? getHslFromAnimation(this.color));\n  }\n\n  getMass() {\n    return this.getRadius() ** 2 * Math.PI / 2;\n  }\n\n  getPosition() {\n    return {\n      x: this.position.x + this.offset.x,\n      y: this.position.y + this.offset.y,\n      z: this.position.z\n    };\n  }\n\n  getRadius() {\n    return this.bubble.radius ?? this.size.value;\n  }\n\n  getStrokeColor() {\n    return this._getRollColor(this.bubble.color ?? getHslFromAnimation(this.strokeColor));\n  }\n\n  init(id, position, overrideOptions, group) {\n    const container = this.container,\n          engine = this._engine;\n    this.id = id;\n    this.group = group;\n    this.fill = true;\n    this.pathRotation = false;\n    this.close = true;\n    this.lastPathTime = 0;\n    this.destroyed = false;\n    this.unbreakable = false;\n    this.rotation = 0;\n    this.misplaced = false;\n    this.retina = {\n      maxDistance: {}\n    };\n    this.outType = \"normal\";\n    this.ignoresResizeRatio = true;\n    const pxRatio = container.retina.pixelRatio,\n          mainOptions = container.actualOptions,\n          particlesOptions = loadParticlesOptions(this._engine, container, mainOptions.particles),\n          shapeType = particlesOptions.shape.type,\n          {\n      reduceDuplicates\n    } = particlesOptions;\n    this.shape = itemFromSingleOrMultiple(shapeType, this.id, reduceDuplicates);\n    const shapeOptions = particlesOptions.shape;\n\n    if (overrideOptions && overrideOptions.shape && overrideOptions.shape.type) {\n      const overrideShapeType = overrideOptions.shape.type,\n            shape = itemFromSingleOrMultiple(overrideShapeType, this.id, reduceDuplicates);\n\n      if (shape) {\n        this.shape = shape;\n        shapeOptions.load(overrideOptions.shape);\n      }\n    }\n\n    this.shapeData = this._loadShapeData(shapeOptions, reduceDuplicates);\n    particlesOptions.load(overrideOptions);\n    const shapeData = this.shapeData;\n\n    if (shapeData) {\n      particlesOptions.load(shapeData.particles);\n    }\n\n    const interactivity = new Interactivity(engine, container);\n    interactivity.load(container.actualOptions.interactivity);\n    interactivity.load(particlesOptions.interactivity);\n    this.interactivity = interactivity;\n    this.fill = shapeData?.fill ?? particlesOptions.shape.fill;\n    this.close = shapeData?.close ?? particlesOptions.shape.close;\n    this.options = particlesOptions;\n    const pathOptions = this.options.move.path;\n    this.pathDelay = getValue(pathOptions.delay) * 1000;\n\n    if (pathOptions.generator) {\n      this.pathGenerator = this._engine.plugins.getPathGenerator(pathOptions.generator);\n\n      if (this.pathGenerator && container.addPath(pathOptions.generator, this.pathGenerator)) {\n        this.pathGenerator.init(container);\n      }\n    }\n\n    container.retina.initParticle(this);\n    this.size = initParticleNumericAnimationValue(this.options.size, pxRatio);\n    this.bubble = {\n      inRange: false\n    };\n    this.slow = {\n      inRange: false,\n      factor: 1\n    };\n\n    this._initPosition(position);\n\n    this.initialVelocity = this._calculateVelocity();\n    this.velocity = this.initialVelocity.copy();\n    this.moveDecay = 1 - getRangeValue(this.options.move.decay);\n    const particles = container.particles;\n    particles.needsSort = particles.needsSort || particles.lastZIndex < this.position.z;\n    particles.lastZIndex = this.position.z;\n    this.zIndexFactor = this.position.z / container.zLayers;\n    this.sides = 24;\n    let drawer = container.drawers.get(this.shape);\n\n    if (!drawer) {\n      drawer = this._engine.plugins.getShapeDrawer(this.shape);\n\n      if (drawer) {\n        container.drawers.set(this.shape, drawer);\n      }\n    }\n\n    if (drawer && drawer.loadShape) {\n      drawer.loadShape(this);\n    }\n\n    const sideCountFunc = drawer?.getSidesCount;\n\n    if (sideCountFunc) {\n      this.sides = sideCountFunc(this);\n    }\n\n    this.spawning = false;\n    this.shadowColor = rangeColorToRgb(this.options.shadow.color);\n\n    for (const updater of container.particles.updaters) {\n      updater.init(this);\n    }\n\n    for (const mover of container.particles.movers) {\n      mover.init && mover.init(this);\n    }\n\n    if (drawer && drawer.particleInit) {\n      drawer.particleInit(container, this);\n    }\n\n    for (const [, plugin] of container.plugins) {\n      plugin.particleCreated && plugin.particleCreated(this);\n    }\n  }\n\n  isInsideCanvas() {\n    const radius = this.getRadius(),\n          canvasSize = this.container.canvas.size,\n          position = this.position;\n    return position.x >= -radius && position.y >= -radius && position.y <= canvasSize.height + radius && position.x <= canvasSize.width + radius;\n  }\n\n  isVisible() {\n    return !this.destroyed && !this.spawning && this.isInsideCanvas();\n  }\n\n  reset() {\n    for (const updater of this.container.particles.updaters) {\n      updater.reset && updater.reset(this);\n    }\n  }\n\n}","map":{"version":3,"sources":["D:/mitsukimiyagi-portfolio/node_modules/tsparticles-engine/esm/Core/Particle.js"],"names":["calcExactPositionOrRandomFromSize","clamp","getDistance","getParticleBaseVelocity","getParticleDirectionAngle","getRandom","getRangeValue","getValue","randomInRange","setRangeValue","deepExtend","getPosition","initParticleNumericAnimationValue","isInArray","itemFromSingleOrMultiple","getHslFromAnimation","rangeColorToRgb","Interactivity","Vector","Vector3d","alterHsl","errorPrefix","loadParticlesOptions","fixOutMode","data","outMode","checkModes","diameter","radius","coord","maxCoord","setCb","Particle","constructor","engine","id","container","position","overrideOptions","group","_calcPosition","zIndex","tryCount","plugin","plugins","pluginPos","particlePosition","undefined","create","x","y","canvasSize","canvas","size","exactPosition","pos","getRadius","outModes","options","move","fixHorizontal","width","value","fixVertical","height","left","default","right","top","bottom","_checkOverlap","_calculateVelocity","baseVelocity","direction","res","copy","moveOptions","rad","Math","PI","angle","radOffset","offset","range","straight","random","speed","length","collisionsOptions","collisions","enable","overlapOptions","overlap","retries","Error","particles","find","particle","_getRollColor","color","roll","backColor","alter","backFactor","horizontal","vertical","backSum","rolled","floor","type","_initPosition","zIndexValue","zLayers","initialPosition","moveCenter","center","mode","outType","origin","_loadShapeData","shapeOptions","reduceDuplicates","shapeData","shape","close","fill","_engine","init","destroy","override","unbreakable","destroyed","bubble","inRange","slow","pathGenerator","particleDestroyed","updater","updaters","reset","draw","delta","drawParticlePlugin","drawParticle","getFillColor","getMass","z","getStrokeColor","strokeColor","pathRotation","lastPathTime","rotation","misplaced","retina","maxDistance","ignoresResizeRatio","pxRatio","pixelRatio","mainOptions","actualOptions","particlesOptions","shapeType","overrideShapeType","load","interactivity","pathOptions","path","pathDelay","delay","generator","getPathGenerator","addPath","initParticle","factor","initialVelocity","velocity","moveDecay","decay","needsSort","lastZIndex","zIndexFactor","sides","drawer","drawers","get","getShapeDrawer","set","loadShape","sideCountFunc","getSidesCount","spawning","shadowColor","shadow","mover","movers","particleInit","particleCreated","isInsideCanvas","isVisible"],"mappings":"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","sourcesContent":["import { calcExactPositionOrRandomFromSize, clamp, getDistance, getParticleBaseVelocity, getParticleDirectionAngle, getRandom, getRangeValue, getValue, randomInRange, setRangeValue, } from \"../Utils/NumberUtils\";\nimport { deepExtend, getPosition, initParticleNumericAnimationValue, isInArray, itemFromSingleOrMultiple, } from \"../Utils/Utils\";\nimport { getHslFromAnimation, rangeColorToRgb } from \"../Utils/ColorUtils\";\nimport { Interactivity } from \"../Options/Classes/Interactivity/Interactivity\";\nimport { Vector } from \"./Utils/Vector\";\nimport { Vector3d } from \"./Utils/Vector3d\";\nimport { alterHsl } from \"../Utils/CanvasUtils\";\nimport { errorPrefix } from \"./Utils/Constants\";\nimport { loadParticlesOptions } from \"../Utils/OptionsUtils\";\nconst fixOutMode = (data) => {\n    if (!isInArray(data.outMode, data.checkModes)) {\n        return;\n    }\n    const diameter = data.radius * 2;\n    if (data.coord > data.maxCoord - diameter) {\n        data.setCb(-data.radius);\n    }\n    else if (data.coord < diameter) {\n        data.setCb(data.radius);\n    }\n};\nexport class Particle {\n    constructor(engine, id, container, position, overrideOptions, group) {\n        this.container = container;\n        this._calcPosition = (container, position, zIndex, tryCount = 0) => {\n            for (const [, plugin] of container.plugins) {\n                const pluginPos = plugin.particlePosition !== undefined ? plugin.particlePosition(position, this) : undefined;\n                if (pluginPos) {\n                    return Vector3d.create(pluginPos.x, pluginPos.y, zIndex);\n                }\n            }\n            const canvasSize = container.canvas.size, exactPosition = calcExactPositionOrRandomFromSize({\n                size: canvasSize,\n                position: position,\n            }), pos = Vector3d.create(exactPosition.x, exactPosition.y, zIndex), radius = this.getRadius(), outModes = this.options.move.outModes, fixHorizontal = (outMode) => {\n                fixOutMode({\n                    outMode,\n                    checkModes: [\"bounce\", \"bounce-horizontal\"],\n                    coord: pos.x,\n                    maxCoord: container.canvas.size.width,\n                    setCb: (value) => (pos.x += value),\n                    radius,\n                });\n            }, fixVertical = (outMode) => {\n                fixOutMode({\n                    outMode,\n                    checkModes: [\"bounce\", \"bounce-vertical\"],\n                    coord: pos.y,\n                    maxCoord: container.canvas.size.height,\n                    setCb: (value) => (pos.y += value),\n                    radius,\n                });\n            };\n            fixHorizontal(outModes.left ?? outModes.default);\n            fixHorizontal(outModes.right ?? outModes.default);\n            fixVertical(outModes.top ?? outModes.default);\n            fixVertical(outModes.bottom ?? outModes.default);\n            if (this._checkOverlap(pos, tryCount)) {\n                return this._calcPosition(container, undefined, zIndex, tryCount + 1);\n            }\n            return pos;\n        };\n        this._calculateVelocity = () => {\n            const baseVelocity = getParticleBaseVelocity(this.direction), res = baseVelocity.copy(), moveOptions = this.options.move;\n            if (moveOptions.direction === \"inside\" || moveOptions.direction === \"outside\") {\n                return res;\n            }\n            const rad = (Math.PI / 180) * getRangeValue(moveOptions.angle.value), radOffset = (Math.PI / 180) * getRangeValue(moveOptions.angle.offset), range = {\n                left: radOffset - rad / 2,\n                right: radOffset + rad / 2,\n            };\n            if (!moveOptions.straight) {\n                res.angle += randomInRange(setRangeValue(range.left, range.right));\n            }\n            if (moveOptions.random && typeof moveOptions.speed === \"number\") {\n                res.length *= getRandom();\n            }\n            return res;\n        };\n        this._checkOverlap = (pos, tryCount = 0) => {\n            const collisionsOptions = this.options.collisions, radius = this.getRadius();\n            if (!collisionsOptions.enable) {\n                return false;\n            }\n            const overlapOptions = collisionsOptions.overlap;\n            if (overlapOptions.enable) {\n                return false;\n            }\n            const retries = overlapOptions.retries;\n            if (retries >= 0 && tryCount > retries) {\n                throw new Error(`${errorPrefix} particle is overlapping and can't be placed`);\n            }\n            return !!this.container.particles.find((particle) => getDistance(pos, particle.position) < radius + particle.getRadius());\n        };\n        this._getRollColor = (color) => {\n            if (!color || !this.roll || (!this.backColor && !this.roll.alter)) {\n                return color;\n            }\n            const backFactor = this.roll.horizontal && this.roll.vertical ? 2 : 1, backSum = this.roll.horizontal ? Math.PI / 2 : 0, rolled = Math.floor(((this.roll.angle ?? 0) + backSum) / (Math.PI / backFactor)) % 2;\n            if (!rolled) {\n                return color;\n            }\n            if (this.backColor) {\n                return this.backColor;\n            }\n            if (this.roll.alter) {\n                return alterHsl(color, this.roll.alter.type, this.roll.alter.value);\n            }\n            return color;\n        };\n        this._initPosition = (position) => {\n            const container = this.container, zIndexValue = getRangeValue(this.options.zIndex.value);\n            this.position = this._calcPosition(container, position, clamp(zIndexValue, 0, container.zLayers));\n            this.initialPosition = this.position.copy();\n            const canvasSize = container.canvas.size;\n            this.moveCenter = {\n                ...getPosition(this.options.move.center, canvasSize),\n                radius: this.options.move.center.radius ?? 0,\n                mode: this.options.move.center.mode ?? \"percent\",\n            };\n            this.direction = getParticleDirectionAngle(this.options.move.direction, this.position, this.moveCenter);\n            switch (this.options.move.direction) {\n                case \"inside\":\n                    this.outType = \"inside\";\n                    break;\n                case \"outside\":\n                    this.outType = \"outside\";\n                    break;\n            }\n            this.offset = Vector.origin;\n        };\n        this._loadShapeData = (shapeOptions, reduceDuplicates) => {\n            const shapeData = shapeOptions.options[this.shape];\n            if (!shapeData) {\n                return;\n            }\n            return deepExtend({\n                close: shapeOptions.close,\n                fill: shapeOptions.fill,\n            }, itemFromSingleOrMultiple(shapeData, this.id, reduceDuplicates));\n        };\n        this._engine = engine;\n        this.init(id, position, overrideOptions, group);\n    }\n    destroy(override) {\n        if (this.unbreakable || this.destroyed) {\n            return;\n        }\n        this.destroyed = true;\n        this.bubble.inRange = false;\n        this.slow.inRange = false;\n        const container = this.container, pathGenerator = this.pathGenerator;\n        for (const [, plugin] of container.plugins) {\n            if (plugin.particleDestroyed) {\n                plugin.particleDestroyed(this, override);\n            }\n        }\n        for (const updater of container.particles.updaters) {\n            if (updater.particleDestroyed) {\n                updater.particleDestroyed(this, override);\n            }\n        }\n        if (pathGenerator) {\n            pathGenerator.reset(this);\n        }\n    }\n    draw(delta) {\n        const container = this.container;\n        for (const [, plugin] of container.plugins) {\n            container.canvas.drawParticlePlugin(plugin, this, delta);\n        }\n        container.canvas.drawParticle(this, delta);\n    }\n    getFillColor() {\n        return this._getRollColor(this.bubble.color ?? getHslFromAnimation(this.color));\n    }\n    getMass() {\n        return (this.getRadius() ** 2 * Math.PI) / 2;\n    }\n    getPosition() {\n        return {\n            x: this.position.x + this.offset.x,\n            y: this.position.y + this.offset.y,\n            z: this.position.z,\n        };\n    }\n    getRadius() {\n        return this.bubble.radius ?? this.size.value;\n    }\n    getStrokeColor() {\n        return this._getRollColor(this.bubble.color ?? getHslFromAnimation(this.strokeColor));\n    }\n    init(id, position, overrideOptions, group) {\n        const container = this.container, engine = this._engine;\n        this.id = id;\n        this.group = group;\n        this.fill = true;\n        this.pathRotation = false;\n        this.close = true;\n        this.lastPathTime = 0;\n        this.destroyed = false;\n        this.unbreakable = false;\n        this.rotation = 0;\n        this.misplaced = false;\n        this.retina = {\n            maxDistance: {},\n        };\n        this.outType = \"normal\";\n        this.ignoresResizeRatio = true;\n        const pxRatio = container.retina.pixelRatio, mainOptions = container.actualOptions, particlesOptions = loadParticlesOptions(this._engine, container, mainOptions.particles), shapeType = particlesOptions.shape.type, { reduceDuplicates } = particlesOptions;\n        this.shape = itemFromSingleOrMultiple(shapeType, this.id, reduceDuplicates);\n        const shapeOptions = particlesOptions.shape;\n        if (overrideOptions && overrideOptions.shape && overrideOptions.shape.type) {\n            const overrideShapeType = overrideOptions.shape.type, shape = itemFromSingleOrMultiple(overrideShapeType, this.id, reduceDuplicates);\n            if (shape) {\n                this.shape = shape;\n                shapeOptions.load(overrideOptions.shape);\n            }\n        }\n        this.shapeData = this._loadShapeData(shapeOptions, reduceDuplicates);\n        particlesOptions.load(overrideOptions);\n        const shapeData = this.shapeData;\n        if (shapeData) {\n            particlesOptions.load(shapeData.particles);\n        }\n        const interactivity = new Interactivity(engine, container);\n        interactivity.load(container.actualOptions.interactivity);\n        interactivity.load(particlesOptions.interactivity);\n        this.interactivity = interactivity;\n        this.fill = shapeData?.fill ?? particlesOptions.shape.fill;\n        this.close = shapeData?.close ?? particlesOptions.shape.close;\n        this.options = particlesOptions;\n        const pathOptions = this.options.move.path;\n        this.pathDelay = getValue(pathOptions.delay) * 1000;\n        if (pathOptions.generator) {\n            this.pathGenerator = this._engine.plugins.getPathGenerator(pathOptions.generator);\n            if (this.pathGenerator && container.addPath(pathOptions.generator, this.pathGenerator)) {\n                this.pathGenerator.init(container);\n            }\n        }\n        container.retina.initParticle(this);\n        this.size = initParticleNumericAnimationValue(this.options.size, pxRatio);\n        this.bubble = {\n            inRange: false,\n        };\n        this.slow = {\n            inRange: false,\n            factor: 1,\n        };\n        this._initPosition(position);\n        this.initialVelocity = this._calculateVelocity();\n        this.velocity = this.initialVelocity.copy();\n        this.moveDecay = 1 - getRangeValue(this.options.move.decay);\n        const particles = container.particles;\n        particles.needsSort = particles.needsSort || particles.lastZIndex < this.position.z;\n        particles.lastZIndex = this.position.z;\n        this.zIndexFactor = this.position.z / container.zLayers;\n        this.sides = 24;\n        let drawer = container.drawers.get(this.shape);\n        if (!drawer) {\n            drawer = this._engine.plugins.getShapeDrawer(this.shape);\n            if (drawer) {\n                container.drawers.set(this.shape, drawer);\n            }\n        }\n        if (drawer && drawer.loadShape) {\n            drawer.loadShape(this);\n        }\n        const sideCountFunc = drawer?.getSidesCount;\n        if (sideCountFunc) {\n            this.sides = sideCountFunc(this);\n        }\n        this.spawning = false;\n        this.shadowColor = rangeColorToRgb(this.options.shadow.color);\n        for (const updater of container.particles.updaters) {\n            updater.init(this);\n        }\n        for (const mover of container.particles.movers) {\n            mover.init && mover.init(this);\n        }\n        if (drawer && drawer.particleInit) {\n            drawer.particleInit(container, this);\n        }\n        for (const [, plugin] of container.plugins) {\n            plugin.particleCreated && plugin.particleCreated(this);\n        }\n    }\n    isInsideCanvas() {\n        const radius = this.getRadius(), canvasSize = this.container.canvas.size, position = this.position;\n        return (position.x >= -radius &&\n            position.y >= -radius &&\n            position.y <= canvasSize.height + radius &&\n            position.x <= canvasSize.width + radius);\n    }\n    isVisible() {\n        return !this.destroyed && !this.spawning && this.isInsideCanvas();\n    }\n    reset() {\n        for (const updater of this.container.particles.updaters) {\n            updater.reset && updater.reset(this);\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module"}