{"ast":null,"code":"import { errorPrefix } from \"tsparticles-engine\";\nimport { replaceImageColor } from \"./Utils\";\nexport class ImageDrawer {\n  constructor(engine) {\n    this.loadImageShape = async imageShape => {\n      if (!this._engine.loadImage) {\n        throw new Error(`${errorPrefix} image shape not initialized`);\n      }\n\n      await this._engine.loadImage({\n        gif: imageShape.gif,\n        name: imageShape.name,\n        replaceColor: imageShape.replaceColor ?? imageShape.replace_color ?? false,\n        src: imageShape.src\n      });\n    };\n\n    this._engine = engine;\n  }\n\n  addImage(image) {\n    if (!this._engine.images) {\n      this._engine.images = [];\n    }\n\n    this._engine.images.push(image);\n  }\n\n  draw(context, particle, radius, opacity, delta) {\n    const image = particle.image,\n          element = image?.element;\n\n    if (!image) {\n      return;\n    }\n\n    context.globalAlpha = opacity;\n\n    if (image.gif && image.gifData) {\n      const offscreenCanvas = new OffscreenCanvas(image.gifData.width, image.gifData.height),\n            offscreenContext = offscreenCanvas.getContext(\"2d\");\n\n      if (!offscreenContext) {\n        throw new Error(\"could not create offscreen canvas context\");\n      }\n\n      offscreenContext.imageSmoothingQuality = \"low\";\n      offscreenContext.imageSmoothingEnabled = false;\n      offscreenContext.clearRect(0, 0, offscreenCanvas.width, offscreenCanvas.height);\n\n      if (particle.gifLoopCount === undefined) {\n        particle.gifLoopCount = image.gifLoopCount ?? 0;\n      }\n\n      let frameIndex = particle.gifFrame ?? 0;\n      const pos = {\n        x: -image.gifData.width * 0.5,\n        y: -image.gifData.height * 0.5\n      },\n            frame = image.gifData.frames[frameIndex];\n\n      if (particle.gifTime === undefined) {\n        particle.gifTime = 0;\n      }\n\n      if (!frame.bitmap) {\n        return;\n      }\n\n      context.scale(radius / image.gifData.width, radius / image.gifData.height);\n\n      switch (frame.disposalMethod) {\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 0:\n          offscreenContext.drawImage(frame.bitmap, frame.left, frame.top);\n          context.drawImage(offscreenCanvas, pos.x, pos.y);\n          offscreenContext.clearRect(0, 0, offscreenCanvas.width, offscreenCanvas.height);\n          break;\n\n        case 1:\n          offscreenContext.drawImage(frame.bitmap, frame.left, frame.top);\n          context.drawImage(offscreenCanvas, pos.x, pos.y);\n          break;\n\n        case 2:\n          offscreenContext.drawImage(frame.bitmap, frame.left, frame.top);\n          context.drawImage(offscreenCanvas, pos.x, pos.y);\n          offscreenContext.clearRect(0, 0, offscreenCanvas.width, offscreenCanvas.height);\n\n          if (image.gifData.globalColorTable.length === 0) {\n            offscreenContext.putImageData(image.gifData.frames[0].image, pos.x + frame.left, pos.y + frame.top);\n          } else {\n            offscreenContext.putImageData(image.gifData.backgroundImage, pos.x, pos.y);\n          }\n\n          break;\n\n        case 3:\n          {\n            const previousImageData = offscreenContext.getImageData(0, 0, offscreenCanvas.width, offscreenCanvas.height);\n            offscreenContext.drawImage(frame.bitmap, frame.left, frame.top);\n            context.drawImage(offscreenCanvas, pos.x, pos.y);\n            offscreenContext.clearRect(0, 0, offscreenCanvas.width, offscreenCanvas.height);\n            offscreenContext.putImageData(previousImageData, 0, 0);\n          }\n          break;\n      }\n\n      particle.gifTime += delta.value;\n\n      if (particle.gifTime > frame.delayTime) {\n        particle.gifTime -= frame.delayTime;\n\n        if (++frameIndex >= image.gifData.frames.length) {\n          if (--particle.gifLoopCount <= 0) {\n            return;\n          }\n\n          frameIndex = 0;\n          offscreenContext.clearRect(0, 0, offscreenCanvas.width, offscreenCanvas.height);\n        }\n\n        particle.gifFrame = frameIndex;\n      }\n\n      context.scale(image.gifData.width / radius, image.gifData.height / radius);\n    } else if (element) {\n      const ratio = image.ratio,\n            pos = {\n        x: -radius,\n        y: -radius\n      };\n      context.drawImage(element, pos.x, pos.y, radius * 2, radius * 2 / ratio);\n    }\n\n    context.globalAlpha = 1;\n  }\n\n  getSidesCount() {\n    return 12;\n  }\n\n  async init(container) {\n    const options = container.actualOptions;\n\n    if (!options.preload || !this._engine.loadImage) {\n      return;\n    }\n\n    for (const imageData of options.preload) {\n      await this._engine.loadImage(imageData);\n    }\n  }\n\n  loadShape(particle) {\n    if (particle.shape !== \"image\" && particle.shape !== \"images\") {\n      return;\n    }\n\n    if (!this._engine.images) {\n      this._engine.images = [];\n    }\n\n    const imageData = particle.shapeData,\n          image = this._engine.images.find(t => t.name === imageData.name || t.source === imageData.src);\n\n    if (!image) {\n      this.loadImageShape(imageData).then(() => {\n        this.loadShape(particle);\n      });\n    }\n  }\n\n  particleInit(container, particle) {\n    if (particle.shape !== \"image\" && particle.shape !== \"images\") {\n      return;\n    }\n\n    if (!this._engine.images) {\n      this._engine.images = [];\n    }\n\n    const images = this._engine.images,\n          imageData = particle.shapeData,\n          color = particle.getFillColor(),\n          image = images.find(t => t.name === imageData.name || t.source === imageData.src);\n\n    if (!image) {\n      return;\n    }\n\n    const replaceColor = imageData.replaceColor ?? imageData.replace_color ?? image.replaceColor;\n\n    if (image.loading) {\n      setTimeout(() => {\n        this.particleInit(container, particle);\n      });\n      return;\n    }\n\n    (async () => {\n      let imageRes;\n\n      if (image.svgData && color) {\n        imageRes = await replaceImageColor(image, imageData, color, particle);\n      } else {\n        imageRes = {\n          color,\n          data: image,\n          element: image.element,\n          gif: image.gif,\n          gifData: image.gifData,\n          gifLoopCount: image.gifLoopCount,\n          loaded: true,\n          ratio: imageData.width && imageData.height ? imageData.width / imageData.height : image.ratio ?? 1,\n          replaceColor: replaceColor,\n          source: imageData.src\n        };\n      }\n\n      if (!imageRes.ratio) {\n        imageRes.ratio = 1;\n      }\n\n      const fill = imageData.fill ?? particle.fill,\n            close = imageData.close ?? particle.close,\n            imageShape = {\n        image: imageRes,\n        fill,\n        close\n      };\n      particle.image = imageShape.image;\n      particle.fill = imageShape.fill;\n      particle.close = imageShape.close;\n    })();\n  }\n\n}","map":{"version":3,"sources":["D:/mitsukimiyagi-portfolio/node_modules/tsparticles-shape-image/esm/ImageDrawer.js"],"names":["errorPrefix","replaceImageColor","ImageDrawer","constructor","engine","loadImageShape","imageShape","_engine","loadImage","Error","gif","name","replaceColor","replace_color","src","addImage","image","images","push","draw","context","particle","radius","opacity","delta","element","globalAlpha","gifData","offscreenCanvas","OffscreenCanvas","width","height","offscreenContext","getContext","imageSmoothingQuality","imageSmoothingEnabled","clearRect","gifLoopCount","undefined","frameIndex","gifFrame","pos","x","y","frame","frames","gifTime","bitmap","scale","disposalMethod","drawImage","left","top","globalColorTable","length","putImageData","backgroundImage","previousImageData","getImageData","value","delayTime","ratio","getSidesCount","init","container","options","actualOptions","preload","imageData","loadShape","shape","shapeData","find","t","source","then","particleInit","color","getFillColor","loading","setTimeout","imageRes","svgData","data","loaded","fill","close"],"mappings":"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","sourcesContent":["import { errorPrefix } from \"tsparticles-engine\";\nimport { replaceImageColor } from \"./Utils\";\nexport class ImageDrawer {\n    constructor(engine) {\n        this.loadImageShape = async (imageShape) => {\n            if (!this._engine.loadImage) {\n                throw new Error(`${errorPrefix} image shape not initialized`);\n            }\n            await this._engine.loadImage({\n                gif: imageShape.gif,\n                name: imageShape.name,\n                replaceColor: imageShape.replaceColor ?? imageShape.replace_color ?? false,\n                src: imageShape.src,\n            });\n        };\n        this._engine = engine;\n    }\n    addImage(image) {\n        if (!this._engine.images) {\n            this._engine.images = [];\n        }\n        this._engine.images.push(image);\n    }\n    draw(context, particle, radius, opacity, delta) {\n        const image = particle.image, element = image?.element;\n        if (!image) {\n            return;\n        }\n        context.globalAlpha = opacity;\n        if (image.gif && image.gifData) {\n            const offscreenCanvas = new OffscreenCanvas(image.gifData.width, image.gifData.height), offscreenContext = offscreenCanvas.getContext(\"2d\");\n            if (!offscreenContext) {\n                throw new Error(\"could not create offscreen canvas context\");\n            }\n            offscreenContext.imageSmoothingQuality = \"low\";\n            offscreenContext.imageSmoothingEnabled = false;\n            offscreenContext.clearRect(0, 0, offscreenCanvas.width, offscreenCanvas.height);\n            if (particle.gifLoopCount === undefined) {\n                particle.gifLoopCount = image.gifLoopCount ?? 0;\n            }\n            let frameIndex = particle.gifFrame ?? 0;\n            const pos = { x: -image.gifData.width * 0.5, y: -image.gifData.height * 0.5 }, frame = image.gifData.frames[frameIndex];\n            if (particle.gifTime === undefined) {\n                particle.gifTime = 0;\n            }\n            if (!frame.bitmap) {\n                return;\n            }\n            context.scale(radius / image.gifData.width, radius / image.gifData.height);\n            switch (frame.disposalMethod) {\n                case 4:\n                case 5:\n                case 6:\n                case 7:\n                case 0:\n                    offscreenContext.drawImage(frame.bitmap, frame.left, frame.top);\n                    context.drawImage(offscreenCanvas, pos.x, pos.y);\n                    offscreenContext.clearRect(0, 0, offscreenCanvas.width, offscreenCanvas.height);\n                    break;\n                case 1:\n                    offscreenContext.drawImage(frame.bitmap, frame.left, frame.top);\n                    context.drawImage(offscreenCanvas, pos.x, pos.y);\n                    break;\n                case 2:\n                    offscreenContext.drawImage(frame.bitmap, frame.left, frame.top);\n                    context.drawImage(offscreenCanvas, pos.x, pos.y);\n                    offscreenContext.clearRect(0, 0, offscreenCanvas.width, offscreenCanvas.height);\n                    if (image.gifData.globalColorTable.length === 0) {\n                        offscreenContext.putImageData(image.gifData.frames[0].image, pos.x + frame.left, pos.y + frame.top);\n                    }\n                    else {\n                        offscreenContext.putImageData(image.gifData.backgroundImage, pos.x, pos.y);\n                    }\n                    break;\n                case 3:\n                    {\n                        const previousImageData = offscreenContext.getImageData(0, 0, offscreenCanvas.width, offscreenCanvas.height);\n                        offscreenContext.drawImage(frame.bitmap, frame.left, frame.top);\n                        context.drawImage(offscreenCanvas, pos.x, pos.y);\n                        offscreenContext.clearRect(0, 0, offscreenCanvas.width, offscreenCanvas.height);\n                        offscreenContext.putImageData(previousImageData, 0, 0);\n                    }\n                    break;\n            }\n            particle.gifTime += delta.value;\n            if (particle.gifTime > frame.delayTime) {\n                particle.gifTime -= frame.delayTime;\n                if (++frameIndex >= image.gifData.frames.length) {\n                    if (--particle.gifLoopCount <= 0) {\n                        return;\n                    }\n                    frameIndex = 0;\n                    offscreenContext.clearRect(0, 0, offscreenCanvas.width, offscreenCanvas.height);\n                }\n                particle.gifFrame = frameIndex;\n            }\n            context.scale(image.gifData.width / radius, image.gifData.height / radius);\n        }\n        else if (element) {\n            const ratio = image.ratio, pos = {\n                x: -radius,\n                y: -radius,\n            };\n            context.drawImage(element, pos.x, pos.y, radius * 2, (radius * 2) / ratio);\n        }\n        context.globalAlpha = 1;\n    }\n    getSidesCount() {\n        return 12;\n    }\n    async init(container) {\n        const options = container.actualOptions;\n        if (!options.preload || !this._engine.loadImage) {\n            return;\n        }\n        for (const imageData of options.preload) {\n            await this._engine.loadImage(imageData);\n        }\n    }\n    loadShape(particle) {\n        if (particle.shape !== \"image\" && particle.shape !== \"images\") {\n            return;\n        }\n        if (!this._engine.images) {\n            this._engine.images = [];\n        }\n        const imageData = particle.shapeData, image = this._engine.images.find((t) => t.name === imageData.name || t.source === imageData.src);\n        if (!image) {\n            this.loadImageShape(imageData).then(() => {\n                this.loadShape(particle);\n            });\n        }\n    }\n    particleInit(container, particle) {\n        if (particle.shape !== \"image\" && particle.shape !== \"images\") {\n            return;\n        }\n        if (!this._engine.images) {\n            this._engine.images = [];\n        }\n        const images = this._engine.images, imageData = particle.shapeData, color = particle.getFillColor(), image = images.find((t) => t.name === imageData.name || t.source === imageData.src);\n        if (!image) {\n            return;\n        }\n        const replaceColor = imageData.replaceColor ?? imageData.replace_color ?? image.replaceColor;\n        if (image.loading) {\n            setTimeout(() => {\n                this.particleInit(container, particle);\n            });\n            return;\n        }\n        (async () => {\n            let imageRes;\n            if (image.svgData && color) {\n                imageRes = await replaceImageColor(image, imageData, color, particle);\n            }\n            else {\n                imageRes = {\n                    color,\n                    data: image,\n                    element: image.element,\n                    gif: image.gif,\n                    gifData: image.gifData,\n                    gifLoopCount: image.gifLoopCount,\n                    loaded: true,\n                    ratio: imageData.width && imageData.height ? imageData.width / imageData.height : image.ratio ?? 1,\n                    replaceColor: replaceColor,\n                    source: imageData.src,\n                };\n            }\n            if (!imageRes.ratio) {\n                imageRes.ratio = 1;\n            }\n            const fill = imageData.fill ?? particle.fill, close = imageData.close ?? particle.close, imageShape = {\n                image: imageRes,\n                fill,\n                close,\n            };\n            particle.image = imageShape.image;\n            particle.fill = imageShape.fill;\n            particle.close = imageShape.close;\n        })();\n    }\n}\n"]},"metadata":{},"sourceType":"module"}