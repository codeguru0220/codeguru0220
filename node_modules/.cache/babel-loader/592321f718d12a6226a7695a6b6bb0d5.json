{"ast":null,"code":"import { Circle, ExternalInteractorBase, Rectangle, colorMix, divMode, divModeExecute, getDistance, getRangeMax, isDivModeEnabled, isInArray, itemFromSingleOrMultiple, mouseLeaveEvent, mouseMoveEvent, rangeColorToHsl, rgbToHsl } from \"tsparticles-engine\";\nimport { Bubble } from \"./Options/Classes/Bubble\";\nimport { calculateBubbleValue } from \"./Utils\";\nexport class Bubbler extends ExternalInteractorBase {\n  constructor(container) {\n    super(container);\n\n    this._clickBubble = () => {\n      const container = this.container,\n            options = container.actualOptions,\n            mouseClickPos = container.interactivity.mouse.clickPosition,\n            bubbleOptions = options.interactivity.modes.bubble;\n\n      if (!bubbleOptions || !mouseClickPos) {\n        return;\n      }\n\n      if (!container.bubble) {\n        container.bubble = {};\n      }\n\n      const distance = container.retina.bubbleModeDistance;\n\n      if (!distance || distance < 0) {\n        return;\n      }\n\n      const query = container.particles.quadTree.queryCircle(mouseClickPos, distance, p => this.isEnabled(p)),\n            {\n        bubble\n      } = container;\n\n      for (const particle of query) {\n        if (!bubble.clicking) {\n          continue;\n        }\n\n        particle.bubble.inRange = !bubble.durationEnd;\n        const pos = particle.getPosition(),\n              distMouse = getDistance(pos, mouseClickPos),\n              timeSpent = (new Date().getTime() - (container.interactivity.mouse.clickTime || 0)) / 1000;\n\n        if (timeSpent > bubbleOptions.duration) {\n          bubble.durationEnd = true;\n        }\n\n        if (timeSpent > bubbleOptions.duration * 2) {\n          bubble.clicking = false;\n          bubble.durationEnd = false;\n        }\n\n        const sizeData = {\n          bubbleObj: {\n            optValue: container.retina.bubbleModeSize,\n            value: particle.bubble.radius\n          },\n          particlesObj: {\n            optValue: getRangeMax(particle.options.size.value) * container.retina.pixelRatio,\n            value: particle.size.value\n          },\n          type: \"size\"\n        };\n\n        this._process(particle, distMouse, timeSpent, sizeData);\n\n        const opacityData = {\n          bubbleObj: {\n            optValue: bubbleOptions.opacity,\n            value: particle.bubble.opacity\n          },\n          particlesObj: {\n            optValue: getRangeMax(particle.options.opacity.value),\n            value: particle.opacity?.value ?? 1\n          },\n          type: \"opacity\"\n        };\n\n        this._process(particle, distMouse, timeSpent, opacityData);\n\n        if (!bubble.durationEnd && distMouse <= distance) {\n          this._hoverBubbleColor(particle, distMouse);\n        } else {\n          delete particle.bubble.color;\n        }\n      }\n    };\n\n    this._hoverBubble = () => {\n      const container = this.container,\n            mousePos = container.interactivity.mouse.position,\n            distance = container.retina.bubbleModeDistance;\n\n      if (!distance || distance < 0 || mousePos === undefined) {\n        return;\n      }\n\n      const query = container.particles.quadTree.queryCircle(mousePos, distance, p => this.isEnabled(p));\n\n      for (const particle of query) {\n        particle.bubble.inRange = true;\n        const pos = particle.getPosition(),\n              pointDistance = getDistance(pos, mousePos),\n              ratio = 1 - pointDistance / distance;\n\n        if (pointDistance <= distance) {\n          if (ratio >= 0 && container.interactivity.status === mouseMoveEvent) {\n            this._hoverBubbleSize(particle, ratio);\n\n            this._hoverBubbleOpacity(particle, ratio);\n\n            this._hoverBubbleColor(particle, ratio);\n          }\n        } else {\n          this.reset(particle);\n        }\n\n        if (container.interactivity.status === mouseLeaveEvent) {\n          this.reset(particle);\n        }\n      }\n    };\n\n    this._hoverBubbleColor = (particle, ratio, divBubble) => {\n      const options = this.container.actualOptions,\n            bubbleOptions = divBubble ?? options.interactivity.modes.bubble;\n\n      if (!bubbleOptions) {\n        return;\n      }\n\n      if (!particle.bubble.finalColor) {\n        const modeColor = bubbleOptions.color;\n\n        if (!modeColor) {\n          return;\n        }\n\n        const bubbleColor = itemFromSingleOrMultiple(modeColor);\n        particle.bubble.finalColor = rangeColorToHsl(bubbleColor);\n      }\n\n      if (!particle.bubble.finalColor) {\n        return;\n      }\n\n      if (bubbleOptions.mix) {\n        particle.bubble.color = undefined;\n        const pColor = particle.getFillColor();\n        particle.bubble.color = pColor ? rgbToHsl(colorMix(pColor, particle.bubble.finalColor, 1 - ratio, ratio)) : particle.bubble.finalColor;\n      } else {\n        particle.bubble.color = particle.bubble.finalColor;\n      }\n    };\n\n    this._hoverBubbleOpacity = (particle, ratio, divBubble) => {\n      const container = this.container,\n            options = container.actualOptions,\n            modeOpacity = divBubble?.opacity ?? options.interactivity.modes.bubble?.opacity;\n\n      if (!modeOpacity) {\n        return;\n      }\n\n      const optOpacity = particle.options.opacity.value,\n            pOpacity = particle.opacity?.value ?? 1,\n            opacity = calculateBubbleValue(pOpacity, modeOpacity, getRangeMax(optOpacity), ratio);\n\n      if (opacity !== undefined) {\n        particle.bubble.opacity = opacity;\n      }\n    };\n\n    this._hoverBubbleSize = (particle, ratio, divBubble) => {\n      const container = this.container,\n            modeSize = divBubble?.size ? divBubble.size * container.retina.pixelRatio : container.retina.bubbleModeSize;\n\n      if (modeSize === undefined) {\n        return;\n      }\n\n      const optSize = getRangeMax(particle.options.size.value) * container.retina.pixelRatio,\n            pSize = particle.size.value,\n            size = calculateBubbleValue(pSize, modeSize, optSize, ratio);\n\n      if (size !== undefined) {\n        particle.bubble.radius = size;\n      }\n    };\n\n    this._process = (particle, distMouse, timeSpent, data) => {\n      const container = this.container,\n            bubbleParam = data.bubbleObj.optValue,\n            options = container.actualOptions,\n            bubbleOptions = options.interactivity.modes.bubble;\n\n      if (!bubbleOptions || bubbleParam === undefined) {\n        return;\n      }\n\n      const bubbleDuration = bubbleOptions.duration,\n            bubbleDistance = container.retina.bubbleModeDistance,\n            particlesParam = data.particlesObj.optValue,\n            pObjBubble = data.bubbleObj.value,\n            pObj = data.particlesObj.value || 0,\n            type = data.type;\n\n      if (!bubbleDistance || bubbleDistance < 0 || bubbleParam === particlesParam) {\n        return;\n      }\n\n      if (!container.bubble) {\n        container.bubble = {};\n      }\n\n      if (container.bubble.durationEnd) {\n        if (pObjBubble) {\n          if (type === \"size\") {\n            delete particle.bubble.radius;\n          }\n\n          if (type === \"opacity\") {\n            delete particle.bubble.opacity;\n          }\n        }\n      } else {\n        if (distMouse <= bubbleDistance) {\n          const obj = pObjBubble ?? pObj;\n\n          if (obj !== bubbleParam) {\n            const value = pObj - timeSpent * (pObj - bubbleParam) / bubbleDuration;\n\n            if (type === \"size\") {\n              particle.bubble.radius = value;\n            }\n\n            if (type === \"opacity\") {\n              particle.bubble.opacity = value;\n            }\n          }\n        } else {\n          if (type === \"size\") {\n            delete particle.bubble.radius;\n          }\n\n          if (type === \"opacity\") {\n            delete particle.bubble.opacity;\n          }\n        }\n      }\n    };\n\n    this._singleSelectorHover = (delta, selector, div) => {\n      const container = this.container,\n            selectors = document.querySelectorAll(selector),\n            bubble = container.actualOptions.interactivity.modes.bubble;\n\n      if (!bubble || !selectors.length) {\n        return;\n      }\n\n      selectors.forEach(item => {\n        const elem = item,\n              pxRatio = container.retina.pixelRatio,\n              pos = {\n          x: (elem.offsetLeft + elem.offsetWidth / 2) * pxRatio,\n          y: (elem.offsetTop + elem.offsetHeight / 2) * pxRatio\n        },\n              repulseRadius = elem.offsetWidth / 2 * pxRatio,\n              area = div.type === \"circle\" ? new Circle(pos.x, pos.y, repulseRadius) : new Rectangle(elem.offsetLeft * pxRatio, elem.offsetTop * pxRatio, elem.offsetWidth * pxRatio, elem.offsetHeight * pxRatio),\n              query = container.particles.quadTree.query(area, p => this.isEnabled(p));\n\n        for (const particle of query) {\n          if (!area.contains(particle.getPosition())) {\n            continue;\n          }\n\n          particle.bubble.inRange = true;\n          const divs = bubble.divs,\n                divBubble = divMode(divs, elem);\n\n          if (!particle.bubble.div || particle.bubble.div !== elem) {\n            this.clear(particle, delta, true);\n            particle.bubble.div = elem;\n          }\n\n          this._hoverBubbleSize(particle, 1, divBubble);\n\n          this._hoverBubbleOpacity(particle, 1, divBubble);\n\n          this._hoverBubbleColor(particle, 1, divBubble);\n        }\n      });\n    };\n\n    if (!container.bubble) {\n      container.bubble = {};\n    }\n\n    this.handleClickMode = mode => {\n      if (mode !== \"bubble\") {\n        return;\n      }\n\n      if (!container.bubble) {\n        container.bubble = {};\n      }\n\n      container.bubble.clicking = true;\n    };\n  }\n\n  clear(particle, delta, force) {\n    if (particle.bubble.inRange && !force) {\n      return;\n    }\n\n    delete particle.bubble.div;\n    delete particle.bubble.opacity;\n    delete particle.bubble.radius;\n    delete particle.bubble.color;\n  }\n\n  init() {\n    const container = this.container,\n          bubble = container.actualOptions.interactivity.modes.bubble;\n\n    if (!bubble) {\n      return;\n    }\n\n    container.retina.bubbleModeDistance = bubble.distance * container.retina.pixelRatio;\n\n    if (bubble.size !== undefined) {\n      container.retina.bubbleModeSize = bubble.size * container.retina.pixelRatio;\n    }\n  }\n\n  async interact(delta) {\n    const options = this.container.actualOptions,\n          events = options.interactivity.events,\n          onHover = events.onHover,\n          onClick = events.onClick,\n          hoverEnabled = onHover.enable,\n          hoverMode = onHover.mode,\n          clickEnabled = onClick.enable,\n          clickMode = onClick.mode,\n          divs = events.onDiv;\n\n    if (hoverEnabled && isInArray(\"bubble\", hoverMode)) {\n      this._hoverBubble();\n    } else if (clickEnabled && isInArray(\"bubble\", clickMode)) {\n      this._clickBubble();\n    } else {\n      divModeExecute(\"bubble\", divs, (selector, div) => this._singleSelectorHover(delta, selector, div));\n    }\n  }\n\n  isEnabled(particle) {\n    const container = this.container,\n          options = container.actualOptions,\n          mouse = container.interactivity.mouse,\n          events = (particle?.interactivity ?? options.interactivity).events,\n          {\n      onClick,\n      onDiv,\n      onHover\n    } = events,\n          divBubble = isDivModeEnabled(\"bubble\", onDiv);\n\n    if (!(divBubble || onHover.enable && mouse.position || onClick.enable && mouse.clickPosition)) {\n      return false;\n    }\n\n    return isInArray(\"bubble\", onHover.mode) || isInArray(\"bubble\", onClick.mode) || divBubble;\n  }\n\n  loadModeOptions(options) {\n    if (!options.bubble) {\n      options.bubble = new Bubble();\n    }\n\n    for (var _len = arguments.length, sources = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      sources[_key - 1] = arguments[_key];\n    }\n\n    for (const source of sources) {\n      options.bubble.load(source?.bubble);\n    }\n  }\n\n  reset(particle) {\n    particle.bubble.inRange = false;\n  }\n\n}","map":{"version":3,"sources":["D:/mitsukimiyagi-portfolio/node_modules/tsparticles-interaction-external-bubble/esm/Bubbler.js"],"names":["Circle","ExternalInteractorBase","Rectangle","colorMix","divMode","divModeExecute","getDistance","getRangeMax","isDivModeEnabled","isInArray","itemFromSingleOrMultiple","mouseLeaveEvent","mouseMoveEvent","rangeColorToHsl","rgbToHsl","Bubble","calculateBubbleValue","Bubbler","constructor","container","_clickBubble","options","actualOptions","mouseClickPos","interactivity","mouse","clickPosition","bubbleOptions","modes","bubble","distance","retina","bubbleModeDistance","query","particles","quadTree","queryCircle","p","isEnabled","particle","clicking","inRange","durationEnd","pos","getPosition","distMouse","timeSpent","Date","getTime","clickTime","duration","sizeData","bubbleObj","optValue","bubbleModeSize","value","radius","particlesObj","size","pixelRatio","type","_process","opacityData","opacity","_hoverBubbleColor","color","_hoverBubble","mousePos","position","undefined","pointDistance","ratio","status","_hoverBubbleSize","_hoverBubbleOpacity","reset","divBubble","finalColor","modeColor","bubbleColor","mix","pColor","getFillColor","modeOpacity","optOpacity","pOpacity","modeSize","optSize","pSize","data","bubbleParam","bubbleDuration","bubbleDistance","particlesParam","pObjBubble","pObj","obj","_singleSelectorHover","delta","selector","div","selectors","document","querySelectorAll","length","forEach","item","elem","pxRatio","x","offsetLeft","offsetWidth","y","offsetTop","offsetHeight","repulseRadius","area","contains","divs","clear","handleClickMode","mode","force","init","interact","events","onHover","onClick","hoverEnabled","enable","hoverMode","clickEnabled","clickMode","onDiv","loadModeOptions","sources","source","load"],"mappings":"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","sourcesContent":["import { Circle, ExternalInteractorBase, Rectangle, colorMix, divMode, divModeExecute, getDistance, getRangeMax, isDivModeEnabled, isInArray, itemFromSingleOrMultiple, mouseLeaveEvent, mouseMoveEvent, rangeColorToHsl, rgbToHsl, } from \"tsparticles-engine\";\nimport { Bubble } from \"./Options/Classes/Bubble\";\nimport { calculateBubbleValue } from \"./Utils\";\nexport class Bubbler extends ExternalInteractorBase {\n    constructor(container) {\n        super(container);\n        this._clickBubble = () => {\n            const container = this.container, options = container.actualOptions, mouseClickPos = container.interactivity.mouse.clickPosition, bubbleOptions = options.interactivity.modes.bubble;\n            if (!bubbleOptions || !mouseClickPos) {\n                return;\n            }\n            if (!container.bubble) {\n                container.bubble = {};\n            }\n            const distance = container.retina.bubbleModeDistance;\n            if (!distance || distance < 0) {\n                return;\n            }\n            const query = container.particles.quadTree.queryCircle(mouseClickPos, distance, (p) => this.isEnabled(p)), { bubble } = container;\n            for (const particle of query) {\n                if (!bubble.clicking) {\n                    continue;\n                }\n                particle.bubble.inRange = !bubble.durationEnd;\n                const pos = particle.getPosition(), distMouse = getDistance(pos, mouseClickPos), timeSpent = (new Date().getTime() - (container.interactivity.mouse.clickTime || 0)) / 1000;\n                if (timeSpent > bubbleOptions.duration) {\n                    bubble.durationEnd = true;\n                }\n                if (timeSpent > bubbleOptions.duration * 2) {\n                    bubble.clicking = false;\n                    bubble.durationEnd = false;\n                }\n                const sizeData = {\n                    bubbleObj: {\n                        optValue: container.retina.bubbleModeSize,\n                        value: particle.bubble.radius,\n                    },\n                    particlesObj: {\n                        optValue: getRangeMax(particle.options.size.value) * container.retina.pixelRatio,\n                        value: particle.size.value,\n                    },\n                    type: \"size\",\n                };\n                this._process(particle, distMouse, timeSpent, sizeData);\n                const opacityData = {\n                    bubbleObj: {\n                        optValue: bubbleOptions.opacity,\n                        value: particle.bubble.opacity,\n                    },\n                    particlesObj: {\n                        optValue: getRangeMax(particle.options.opacity.value),\n                        value: particle.opacity?.value ?? 1,\n                    },\n                    type: \"opacity\",\n                };\n                this._process(particle, distMouse, timeSpent, opacityData);\n                if (!bubble.durationEnd && distMouse <= distance) {\n                    this._hoverBubbleColor(particle, distMouse);\n                }\n                else {\n                    delete particle.bubble.color;\n                }\n            }\n        };\n        this._hoverBubble = () => {\n            const container = this.container, mousePos = container.interactivity.mouse.position, distance = container.retina.bubbleModeDistance;\n            if (!distance || distance < 0 || mousePos === undefined) {\n                return;\n            }\n            const query = container.particles.quadTree.queryCircle(mousePos, distance, (p) => this.isEnabled(p));\n            for (const particle of query) {\n                particle.bubble.inRange = true;\n                const pos = particle.getPosition(), pointDistance = getDistance(pos, mousePos), ratio = 1 - pointDistance / distance;\n                if (pointDistance <= distance) {\n                    if (ratio >= 0 && container.interactivity.status === mouseMoveEvent) {\n                        this._hoverBubbleSize(particle, ratio);\n                        this._hoverBubbleOpacity(particle, ratio);\n                        this._hoverBubbleColor(particle, ratio);\n                    }\n                }\n                else {\n                    this.reset(particle);\n                }\n                if (container.interactivity.status === mouseLeaveEvent) {\n                    this.reset(particle);\n                }\n            }\n        };\n        this._hoverBubbleColor = (particle, ratio, divBubble) => {\n            const options = this.container.actualOptions, bubbleOptions = divBubble ?? options.interactivity.modes.bubble;\n            if (!bubbleOptions) {\n                return;\n            }\n            if (!particle.bubble.finalColor) {\n                const modeColor = bubbleOptions.color;\n                if (!modeColor) {\n                    return;\n                }\n                const bubbleColor = itemFromSingleOrMultiple(modeColor);\n                particle.bubble.finalColor = rangeColorToHsl(bubbleColor);\n            }\n            if (!particle.bubble.finalColor) {\n                return;\n            }\n            if (bubbleOptions.mix) {\n                particle.bubble.color = undefined;\n                const pColor = particle.getFillColor();\n                particle.bubble.color = pColor\n                    ? rgbToHsl(colorMix(pColor, particle.bubble.finalColor, 1 - ratio, ratio))\n                    : particle.bubble.finalColor;\n            }\n            else {\n                particle.bubble.color = particle.bubble.finalColor;\n            }\n        };\n        this._hoverBubbleOpacity = (particle, ratio, divBubble) => {\n            const container = this.container, options = container.actualOptions, modeOpacity = divBubble?.opacity ?? options.interactivity.modes.bubble?.opacity;\n            if (!modeOpacity) {\n                return;\n            }\n            const optOpacity = particle.options.opacity.value, pOpacity = particle.opacity?.value ?? 1, opacity = calculateBubbleValue(pOpacity, modeOpacity, getRangeMax(optOpacity), ratio);\n            if (opacity !== undefined) {\n                particle.bubble.opacity = opacity;\n            }\n        };\n        this._hoverBubbleSize = (particle, ratio, divBubble) => {\n            const container = this.container, modeSize = divBubble?.size ? divBubble.size * container.retina.pixelRatio : container.retina.bubbleModeSize;\n            if (modeSize === undefined) {\n                return;\n            }\n            const optSize = getRangeMax(particle.options.size.value) * container.retina.pixelRatio, pSize = particle.size.value, size = calculateBubbleValue(pSize, modeSize, optSize, ratio);\n            if (size !== undefined) {\n                particle.bubble.radius = size;\n            }\n        };\n        this._process = (particle, distMouse, timeSpent, data) => {\n            const container = this.container, bubbleParam = data.bubbleObj.optValue, options = container.actualOptions, bubbleOptions = options.interactivity.modes.bubble;\n            if (!bubbleOptions || bubbleParam === undefined) {\n                return;\n            }\n            const bubbleDuration = bubbleOptions.duration, bubbleDistance = container.retina.bubbleModeDistance, particlesParam = data.particlesObj.optValue, pObjBubble = data.bubbleObj.value, pObj = data.particlesObj.value || 0, type = data.type;\n            if (!bubbleDistance || bubbleDistance < 0 || bubbleParam === particlesParam) {\n                return;\n            }\n            if (!container.bubble) {\n                container.bubble = {};\n            }\n            if (container.bubble.durationEnd) {\n                if (pObjBubble) {\n                    if (type === \"size\") {\n                        delete particle.bubble.radius;\n                    }\n                    if (type === \"opacity\") {\n                        delete particle.bubble.opacity;\n                    }\n                }\n            }\n            else {\n                if (distMouse <= bubbleDistance) {\n                    const obj = pObjBubble ?? pObj;\n                    if (obj !== bubbleParam) {\n                        const value = pObj - (timeSpent * (pObj - bubbleParam)) / bubbleDuration;\n                        if (type === \"size\") {\n                            particle.bubble.radius = value;\n                        }\n                        if (type === \"opacity\") {\n                            particle.bubble.opacity = value;\n                        }\n                    }\n                }\n                else {\n                    if (type === \"size\") {\n                        delete particle.bubble.radius;\n                    }\n                    if (type === \"opacity\") {\n                        delete particle.bubble.opacity;\n                    }\n                }\n            }\n        };\n        this._singleSelectorHover = (delta, selector, div) => {\n            const container = this.container, selectors = document.querySelectorAll(selector), bubble = container.actualOptions.interactivity.modes.bubble;\n            if (!bubble || !selectors.length) {\n                return;\n            }\n            selectors.forEach((item) => {\n                const elem = item, pxRatio = container.retina.pixelRatio, pos = {\n                    x: (elem.offsetLeft + elem.offsetWidth / 2) * pxRatio,\n                    y: (elem.offsetTop + elem.offsetHeight / 2) * pxRatio,\n                }, repulseRadius = (elem.offsetWidth / 2) * pxRatio, area = div.type === \"circle\"\n                    ? new Circle(pos.x, pos.y, repulseRadius)\n                    : new Rectangle(elem.offsetLeft * pxRatio, elem.offsetTop * pxRatio, elem.offsetWidth * pxRatio, elem.offsetHeight * pxRatio), query = container.particles.quadTree.query(area, (p) => this.isEnabled(p));\n                for (const particle of query) {\n                    if (!area.contains(particle.getPosition())) {\n                        continue;\n                    }\n                    particle.bubble.inRange = true;\n                    const divs = bubble.divs, divBubble = divMode(divs, elem);\n                    if (!particle.bubble.div || particle.bubble.div !== elem) {\n                        this.clear(particle, delta, true);\n                        particle.bubble.div = elem;\n                    }\n                    this._hoverBubbleSize(particle, 1, divBubble);\n                    this._hoverBubbleOpacity(particle, 1, divBubble);\n                    this._hoverBubbleColor(particle, 1, divBubble);\n                }\n            });\n        };\n        if (!container.bubble) {\n            container.bubble = {};\n        }\n        this.handleClickMode = (mode) => {\n            if (mode !== \"bubble\") {\n                return;\n            }\n            if (!container.bubble) {\n                container.bubble = {};\n            }\n            container.bubble.clicking = true;\n        };\n    }\n    clear(particle, delta, force) {\n        if (particle.bubble.inRange && !force) {\n            return;\n        }\n        delete particle.bubble.div;\n        delete particle.bubble.opacity;\n        delete particle.bubble.radius;\n        delete particle.bubble.color;\n    }\n    init() {\n        const container = this.container, bubble = container.actualOptions.interactivity.modes.bubble;\n        if (!bubble) {\n            return;\n        }\n        container.retina.bubbleModeDistance = bubble.distance * container.retina.pixelRatio;\n        if (bubble.size !== undefined) {\n            container.retina.bubbleModeSize = bubble.size * container.retina.pixelRatio;\n        }\n    }\n    async interact(delta) {\n        const options = this.container.actualOptions, events = options.interactivity.events, onHover = events.onHover, onClick = events.onClick, hoverEnabled = onHover.enable, hoverMode = onHover.mode, clickEnabled = onClick.enable, clickMode = onClick.mode, divs = events.onDiv;\n        if (hoverEnabled && isInArray(\"bubble\", hoverMode)) {\n            this._hoverBubble();\n        }\n        else if (clickEnabled && isInArray(\"bubble\", clickMode)) {\n            this._clickBubble();\n        }\n        else {\n            divModeExecute(\"bubble\", divs, (selector, div) => this._singleSelectorHover(delta, selector, div));\n        }\n    }\n    isEnabled(particle) {\n        const container = this.container, options = container.actualOptions, mouse = container.interactivity.mouse, events = (particle?.interactivity ?? options.interactivity).events, { onClick, onDiv, onHover } = events, divBubble = isDivModeEnabled(\"bubble\", onDiv);\n        if (!(divBubble || (onHover.enable && mouse.position) || (onClick.enable && mouse.clickPosition))) {\n            return false;\n        }\n        return isInArray(\"bubble\", onHover.mode) || isInArray(\"bubble\", onClick.mode) || divBubble;\n    }\n    loadModeOptions(options, ...sources) {\n        if (!options.bubble) {\n            options.bubble = new Bubble();\n        }\n        for (const source of sources) {\n            options.bubble.load(source?.bubble);\n        }\n    }\n    reset(particle) {\n        particle.bubble.inRange = false;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}