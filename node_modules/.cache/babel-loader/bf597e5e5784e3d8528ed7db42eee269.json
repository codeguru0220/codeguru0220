{"ast":null,"code":"import { Vector, calcPositionOrRandomFromSize, calcPositionOrRandomFromSizeRanged, getDistance, getDistances, getRandom, getRangeValue, getStyleFromRgb, isPointInside, rangeColorToRgb } from \"tsparticles-engine\";\nimport { Absorber } from \"./Options/Classes/Absorber\";\nexport class AbsorberInstance {\n  constructor(absorbers, container, options, position) {\n    this.absorbers = absorbers;\n    this.container = container;\n\n    this._calcPosition = () => {\n      const exactPosition = calcPositionOrRandomFromSizeRanged({\n        size: this.container.canvas.size,\n        position: this.options.position\n      });\n      return Vector.create(exactPosition.x, exactPosition.y);\n    };\n\n    this._updateParticlePosition = (particle, v) => {\n      if (particle.destroyed) {\n        return;\n      }\n\n      const container = this.container,\n            canvasSize = container.canvas.size;\n\n      if (particle.needsNewPosition) {\n        const newPosition = calcPositionOrRandomFromSize({\n          size: canvasSize\n        });\n        particle.position.setTo(newPosition);\n        particle.velocity.setTo(particle.initialVelocity);\n        particle.absorberOrbit = undefined;\n        particle.needsNewPosition = false;\n      }\n\n      if (this.options.orbits) {\n        if (particle.absorberOrbit === undefined) {\n          particle.absorberOrbit = Vector.create(0, 0);\n          particle.absorberOrbit.length = getDistance(particle.getPosition(), this.position);\n          particle.absorberOrbit.angle = getRandom() * Math.PI * 2;\n        }\n\n        if (particle.absorberOrbit.length <= this.size && !this.options.destroy) {\n          const minSize = Math.min(canvasSize.width, canvasSize.height);\n          particle.absorberOrbit.length = minSize * (1 + (getRandom() * 0.2 - 0.1));\n        }\n\n        if (particle.absorberOrbitDirection === undefined) {\n          particle.absorberOrbitDirection = particle.velocity.x >= 0 ? \"clockwise\" : \"counter-clockwise\";\n        }\n\n        const orbitRadius = particle.absorberOrbit.length,\n              orbitAngle = particle.absorberOrbit.angle,\n              orbitDirection = particle.absorberOrbitDirection;\n        particle.velocity.setTo(Vector.origin);\n        const updateFunc = {\n          x: orbitDirection === \"clockwise\" ? Math.cos : Math.sin,\n          y: orbitDirection === \"clockwise\" ? Math.sin : Math.cos\n        };\n        particle.position.x = this.position.x + orbitRadius * updateFunc.x(orbitAngle);\n        particle.position.y = this.position.y + orbitRadius * updateFunc.y(orbitAngle);\n        particle.absorberOrbit.length -= v.length;\n        particle.absorberOrbit.angle += (particle.retina.moveSpeed ?? 0) * container.retina.pixelRatio / 100 * container.retina.reduceFactor;\n      } else {\n        const addV = Vector.origin;\n        addV.length = v.length;\n        addV.angle = v.angle;\n        particle.velocity.addTo(addV);\n      }\n    };\n\n    this.initialPosition = position ? Vector.create(position.x, position.y) : undefined;\n\n    if (options instanceof Absorber) {\n      this.options = options;\n    } else {\n      this.options = new Absorber();\n      this.options.load(options);\n    }\n\n    this.dragging = false;\n    this.name = this.options.name;\n    this.opacity = this.options.opacity;\n    this.size = getRangeValue(this.options.size.value) * container.retina.pixelRatio;\n    this.mass = this.size * this.options.size.density * container.retina.reduceFactor;\n    const limit = this.options.size.limit;\n    this.limit = {\n      radius: limit.radius * container.retina.pixelRatio * container.retina.reduceFactor,\n      mass: limit.mass\n    };\n    this.color = rangeColorToRgb(this.options.color) ?? {\n      b: 0,\n      g: 0,\n      r: 0\n    };\n    this.position = this.initialPosition?.copy() ?? this._calcPosition();\n  }\n\n  attract(particle) {\n    const container = this.container,\n          options = this.options;\n\n    if (options.draggable) {\n      const mouse = container.interactivity.mouse;\n\n      if (mouse.clicking && mouse.downPosition) {\n        const mouseDist = getDistance(this.position, mouse.downPosition);\n\n        if (mouseDist <= this.size) {\n          this.dragging = true;\n        }\n      } else {\n        this.dragging = false;\n      }\n\n      if (this.dragging && mouse.position) {\n        this.position.x = mouse.position.x;\n        this.position.y = mouse.position.y;\n      }\n    }\n\n    const pos = particle.getPosition(),\n          {\n      dx,\n      dy,\n      distance\n    } = getDistances(this.position, pos),\n          v = Vector.create(dx, dy);\n    v.length = this.mass / Math.pow(distance, 2) * container.retina.reduceFactor;\n\n    if (distance < this.size + particle.getRadius()) {\n      const sizeFactor = particle.getRadius() * 0.033 * container.retina.pixelRatio;\n\n      if (this.size > particle.getRadius() && distance < this.size - particle.getRadius() || particle.absorberOrbit !== undefined && particle.absorberOrbit.length < 0) {\n        if (options.destroy) {\n          particle.destroy();\n        } else {\n          particle.needsNewPosition = true;\n\n          this._updateParticlePosition(particle, v);\n        }\n      } else {\n        if (options.destroy) {\n          particle.size.value -= sizeFactor;\n        }\n\n        this._updateParticlePosition(particle, v);\n      }\n\n      if (this.limit.radius <= 0 || this.size < this.limit.radius) {\n        this.size += sizeFactor;\n      }\n\n      if (this.limit.mass <= 0 || this.mass < this.limit.mass) {\n        this.mass += sizeFactor * this.options.size.density * container.retina.reduceFactor;\n      }\n    } else {\n      this._updateParticlePosition(particle, v);\n    }\n  }\n\n  draw(context) {\n    context.translate(this.position.x, this.position.y);\n    context.beginPath();\n    context.arc(0, 0, this.size, 0, Math.PI * 2, false);\n    context.closePath();\n    context.fillStyle = getStyleFromRgb(this.color, this.opacity);\n    context.fill();\n  }\n\n  resize() {\n    const initialPosition = this.initialPosition;\n    this.position = initialPosition && isPointInside(initialPosition, this.container.canvas.size, Vector.origin) ? initialPosition : this._calcPosition();\n  }\n\n}","map":{"version":3,"sources":["D:/mitsukimiyagi-portfolio/node_modules/tsparticles-plugin-absorbers/esm/AbsorberInstance.js"],"names":["Vector","calcPositionOrRandomFromSize","calcPositionOrRandomFromSizeRanged","getDistance","getDistances","getRandom","getRangeValue","getStyleFromRgb","isPointInside","rangeColorToRgb","Absorber","AbsorberInstance","constructor","absorbers","container","options","position","_calcPosition","exactPosition","size","canvas","create","x","y","_updateParticlePosition","particle","v","destroyed","canvasSize","needsNewPosition","newPosition","setTo","velocity","initialVelocity","absorberOrbit","undefined","orbits","length","getPosition","angle","Math","PI","destroy","minSize","min","width","height","absorberOrbitDirection","orbitRadius","orbitAngle","orbitDirection","origin","updateFunc","cos","sin","retina","moveSpeed","pixelRatio","reduceFactor","addV","addTo","initialPosition","load","dragging","name","opacity","value","mass","density","limit","radius","color","b","g","r","copy","attract","draggable","mouse","interactivity","clicking","downPosition","mouseDist","pos","dx","dy","distance","pow","getRadius","sizeFactor","draw","context","translate","beginPath","arc","closePath","fillStyle","fill","resize"],"mappings":"AAAA,SAASA,MAAT,EAAiBC,4BAAjB,EAA+CC,kCAA/C,EAAmFC,WAAnF,EAAgGC,YAAhG,EAA8GC,SAA9G,EAAyHC,aAAzH,EAAwIC,eAAxI,EAAyJC,aAAzJ,EAAwKC,eAAxK,QAAgM,oBAAhM;AACA,SAASC,QAAT,QAAyB,4BAAzB;AACA,OAAO,MAAMC,gBAAN,CAAuB;AAC1BC,EAAAA,WAAW,CAACC,SAAD,EAAYC,SAAZ,EAAuBC,OAAvB,EAAgCC,QAAhC,EAA0C;AACjD,SAAKH,SAAL,GAAiBA,SAAjB;AACA,SAAKC,SAAL,GAAiBA,SAAjB;;AACA,SAAKG,aAAL,GAAqB,MAAM;AACvB,YAAMC,aAAa,GAAGhB,kCAAkC,CAAC;AACrDiB,QAAAA,IAAI,EAAE,KAAKL,SAAL,CAAeM,MAAf,CAAsBD,IADyB;AAErDH,QAAAA,QAAQ,EAAE,KAAKD,OAAL,CAAaC;AAF8B,OAAD,CAAxD;AAIA,aAAOhB,MAAM,CAACqB,MAAP,CAAcH,aAAa,CAACI,CAA5B,EAA+BJ,aAAa,CAACK,CAA7C,CAAP;AACH,KAND;;AAOA,SAAKC,uBAAL,GAA+B,CAACC,QAAD,EAAWC,CAAX,KAAiB;AAC5C,UAAID,QAAQ,CAACE,SAAb,EAAwB;AACpB;AACH;;AACD,YAAMb,SAAS,GAAG,KAAKA,SAAvB;AAAA,YAAkCc,UAAU,GAAGd,SAAS,CAACM,MAAV,CAAiBD,IAAhE;;AACA,UAAIM,QAAQ,CAACI,gBAAb,EAA+B;AAC3B,cAAMC,WAAW,GAAG7B,4BAA4B,CAAC;AAAEkB,UAAAA,IAAI,EAAES;AAAR,SAAD,CAAhD;AACAH,QAAAA,QAAQ,CAACT,QAAT,CAAkBe,KAAlB,CAAwBD,WAAxB;AACAL,QAAAA,QAAQ,CAACO,QAAT,CAAkBD,KAAlB,CAAwBN,QAAQ,CAACQ,eAAjC;AACAR,QAAAA,QAAQ,CAACS,aAAT,GAAyBC,SAAzB;AACAV,QAAAA,QAAQ,CAACI,gBAAT,GAA4B,KAA5B;AACH;;AACD,UAAI,KAAKd,OAAL,CAAaqB,MAAjB,EAAyB;AACrB,YAAIX,QAAQ,CAACS,aAAT,KAA2BC,SAA/B,EAA0C;AACtCV,UAAAA,QAAQ,CAACS,aAAT,GAAyBlC,MAAM,CAACqB,MAAP,CAAc,CAAd,EAAiB,CAAjB,CAAzB;AACAI,UAAAA,QAAQ,CAACS,aAAT,CAAuBG,MAAvB,GAAgClC,WAAW,CAACsB,QAAQ,CAACa,WAAT,EAAD,EAAyB,KAAKtB,QAA9B,CAA3C;AACAS,UAAAA,QAAQ,CAACS,aAAT,CAAuBK,KAAvB,GAA+BlC,SAAS,KAAKmC,IAAI,CAACC,EAAnB,GAAwB,CAAvD;AACH;;AACD,YAAIhB,QAAQ,CAACS,aAAT,CAAuBG,MAAvB,IAAiC,KAAKlB,IAAtC,IAA8C,CAAC,KAAKJ,OAAL,CAAa2B,OAAhE,EAAyE;AACrE,gBAAMC,OAAO,GAAGH,IAAI,CAACI,GAAL,CAAShB,UAAU,CAACiB,KAApB,EAA2BjB,UAAU,CAACkB,MAAtC,CAAhB;AACArB,UAAAA,QAAQ,CAACS,aAAT,CAAuBG,MAAvB,GAAgCM,OAAO,IAAI,KAAKtC,SAAS,KAAK,GAAd,GAAoB,GAAzB,CAAJ,CAAvC;AACH;;AACD,YAAIoB,QAAQ,CAACsB,sBAAT,KAAoCZ,SAAxC,EAAmD;AAC/CV,UAAAA,QAAQ,CAACsB,sBAAT,GACItB,QAAQ,CAACO,QAAT,CAAkBV,CAAlB,IAAuB,CAAvB,GAA2B,WAA3B,GAAyC,mBAD7C;AAEH;;AACD,cAAM0B,WAAW,GAAGvB,QAAQ,CAACS,aAAT,CAAuBG,MAA3C;AAAA,cAAmDY,UAAU,GAAGxB,QAAQ,CAACS,aAAT,CAAuBK,KAAvF;AAAA,cAA8FW,cAAc,GAAGzB,QAAQ,CAACsB,sBAAxH;AACAtB,QAAAA,QAAQ,CAACO,QAAT,CAAkBD,KAAlB,CAAwB/B,MAAM,CAACmD,MAA/B;AACA,cAAMC,UAAU,GAAG;AACf9B,UAAAA,CAAC,EAAE4B,cAAc,KAAK,WAAnB,GAAiCV,IAAI,CAACa,GAAtC,GAA4Cb,IAAI,CAACc,GADrC;AAEf/B,UAAAA,CAAC,EAAE2B,cAAc,KAAK,WAAnB,GAAiCV,IAAI,CAACc,GAAtC,GAA4Cd,IAAI,CAACa;AAFrC,SAAnB;AAIA5B,QAAAA,QAAQ,CAACT,QAAT,CAAkBM,CAAlB,GAAsB,KAAKN,QAAL,CAAcM,CAAd,GAAkB0B,WAAW,GAAGI,UAAU,CAAC9B,CAAX,CAAa2B,UAAb,CAAtD;AACAxB,QAAAA,QAAQ,CAACT,QAAT,CAAkBO,CAAlB,GAAsB,KAAKP,QAAL,CAAcO,CAAd,GAAkByB,WAAW,GAAGI,UAAU,CAAC7B,CAAX,CAAa0B,UAAb,CAAtD;AACAxB,QAAAA,QAAQ,CAACS,aAAT,CAAuBG,MAAvB,IAAiCX,CAAC,CAACW,MAAnC;AACAZ,QAAAA,QAAQ,CAACS,aAAT,CAAuBK,KAAvB,IACM,CAACd,QAAQ,CAAC8B,MAAT,CAAgBC,SAAhB,IAA6B,CAA9B,IAAmC1C,SAAS,CAACyC,MAAV,CAAiBE,UAArD,GAAmE,GAApE,GACI3C,SAAS,CAACyC,MAAV,CAAiBG,YAFzB;AAGH,OA1BD,MA2BK;AACD,cAAMC,IAAI,GAAG3D,MAAM,CAACmD,MAApB;AACAQ,QAAAA,IAAI,CAACtB,MAAL,GAAcX,CAAC,CAACW,MAAhB;AACAsB,QAAAA,IAAI,CAACpB,KAAL,GAAab,CAAC,CAACa,KAAf;AACAd,QAAAA,QAAQ,CAACO,QAAT,CAAkB4B,KAAlB,CAAwBD,IAAxB;AACH;AACJ,KA7CD;;AA8CA,SAAKE,eAAL,GAAuB7C,QAAQ,GAAGhB,MAAM,CAACqB,MAAP,CAAcL,QAAQ,CAACM,CAAvB,EAA0BN,QAAQ,CAACO,CAAnC,CAAH,GAA2CY,SAA1E;;AACA,QAAIpB,OAAO,YAAYL,QAAvB,EAAiC;AAC7B,WAAKK,OAAL,GAAeA,OAAf;AACH,KAFD,MAGK;AACD,WAAKA,OAAL,GAAe,IAAIL,QAAJ,EAAf;AACA,WAAKK,OAAL,CAAa+C,IAAb,CAAkB/C,OAAlB;AACH;;AACD,SAAKgD,QAAL,GAAgB,KAAhB;AACA,SAAKC,IAAL,GAAY,KAAKjD,OAAL,CAAaiD,IAAzB;AACA,SAAKC,OAAL,GAAe,KAAKlD,OAAL,CAAakD,OAA5B;AACA,SAAK9C,IAAL,GAAYb,aAAa,CAAC,KAAKS,OAAL,CAAaI,IAAb,CAAkB+C,KAAnB,CAAb,GAAyCpD,SAAS,CAACyC,MAAV,CAAiBE,UAAtE;AACA,SAAKU,IAAL,GAAY,KAAKhD,IAAL,GAAY,KAAKJ,OAAL,CAAaI,IAAb,CAAkBiD,OAA9B,GAAwCtD,SAAS,CAACyC,MAAV,CAAiBG,YAArE;AACA,UAAMW,KAAK,GAAG,KAAKtD,OAAL,CAAaI,IAAb,CAAkBkD,KAAhC;AACA,SAAKA,KAAL,GAAa;AACTC,MAAAA,MAAM,EAAED,KAAK,CAACC,MAAN,GAAexD,SAAS,CAACyC,MAAV,CAAiBE,UAAhC,GAA6C3C,SAAS,CAACyC,MAAV,CAAiBG,YAD7D;AAETS,MAAAA,IAAI,EAAEE,KAAK,CAACF;AAFH,KAAb;AAIA,SAAKI,KAAL,GAAa9D,eAAe,CAAC,KAAKM,OAAL,CAAawD,KAAd,CAAf,IAAuC;AAChDC,MAAAA,CAAC,EAAE,CAD6C;AAEhDC,MAAAA,CAAC,EAAE,CAF6C;AAGhDC,MAAAA,CAAC,EAAE;AAH6C,KAApD;AAKA,SAAK1D,QAAL,GAAgB,KAAK6C,eAAL,EAAsBc,IAAtB,MAAgC,KAAK1D,aAAL,EAAhD;AACH;;AACD2D,EAAAA,OAAO,CAACnD,QAAD,EAAW;AACd,UAAMX,SAAS,GAAG,KAAKA,SAAvB;AAAA,UAAkCC,OAAO,GAAG,KAAKA,OAAjD;;AACA,QAAIA,OAAO,CAAC8D,SAAZ,EAAuB;AACnB,YAAMC,KAAK,GAAGhE,SAAS,CAACiE,aAAV,CAAwBD,KAAtC;;AACA,UAAIA,KAAK,CAACE,QAAN,IAAkBF,KAAK,CAACG,YAA5B,EAA0C;AACtC,cAAMC,SAAS,GAAG/E,WAAW,CAAC,KAAKa,QAAN,EAAgB8D,KAAK,CAACG,YAAtB,CAA7B;;AACA,YAAIC,SAAS,IAAI,KAAK/D,IAAtB,EAA4B;AACxB,eAAK4C,QAAL,GAAgB,IAAhB;AACH;AACJ,OALD,MAMK;AACD,aAAKA,QAAL,GAAgB,KAAhB;AACH;;AACD,UAAI,KAAKA,QAAL,IAAiBe,KAAK,CAAC9D,QAA3B,EAAqC;AACjC,aAAKA,QAAL,CAAcM,CAAd,GAAkBwD,KAAK,CAAC9D,QAAN,CAAeM,CAAjC;AACA,aAAKN,QAAL,CAAcO,CAAd,GAAkBuD,KAAK,CAAC9D,QAAN,CAAeO,CAAjC;AACH;AACJ;;AACD,UAAM4D,GAAG,GAAG1D,QAAQ,CAACa,WAAT,EAAZ;AAAA,UAAoC;AAAE8C,MAAAA,EAAF;AAAMC,MAAAA,EAAN;AAAUC,MAAAA;AAAV,QAAuBlF,YAAY,CAAC,KAAKY,QAAN,EAAgBmE,GAAhB,CAAvE;AAAA,UAA6FzD,CAAC,GAAG1B,MAAM,CAACqB,MAAP,CAAc+D,EAAd,EAAkBC,EAAlB,CAAjG;AACA3D,IAAAA,CAAC,CAACW,MAAF,GAAY,KAAK8B,IAAL,GAAY3B,IAAI,CAAC+C,GAAL,CAASD,QAAT,EAAmB,CAAnB,CAAb,GAAsCxE,SAAS,CAACyC,MAAV,CAAiBG,YAAlE;;AACA,QAAI4B,QAAQ,GAAG,KAAKnE,IAAL,GAAYM,QAAQ,CAAC+D,SAAT,EAA3B,EAAiD;AAC7C,YAAMC,UAAU,GAAGhE,QAAQ,CAAC+D,SAAT,KAAuB,KAAvB,GAA+B1E,SAAS,CAACyC,MAAV,CAAiBE,UAAnE;;AACA,UAAK,KAAKtC,IAAL,GAAYM,QAAQ,CAAC+D,SAAT,EAAZ,IAAoCF,QAAQ,GAAG,KAAKnE,IAAL,GAAYM,QAAQ,CAAC+D,SAAT,EAA5D,IACC/D,QAAQ,CAACS,aAAT,KAA2BC,SAA3B,IAAwCV,QAAQ,CAACS,aAAT,CAAuBG,MAAvB,GAAgC,CAD7E,EACiF;AAC7E,YAAItB,OAAO,CAAC2B,OAAZ,EAAqB;AACjBjB,UAAAA,QAAQ,CAACiB,OAAT;AACH,SAFD,MAGK;AACDjB,UAAAA,QAAQ,CAACI,gBAAT,GAA4B,IAA5B;;AACA,eAAKL,uBAAL,CAA6BC,QAA7B,EAAuCC,CAAvC;AACH;AACJ,OATD,MAUK;AACD,YAAIX,OAAO,CAAC2B,OAAZ,EAAqB;AACjBjB,UAAAA,QAAQ,CAACN,IAAT,CAAc+C,KAAd,IAAuBuB,UAAvB;AACH;;AACD,aAAKjE,uBAAL,CAA6BC,QAA7B,EAAuCC,CAAvC;AACH;;AACD,UAAI,KAAK2C,KAAL,CAAWC,MAAX,IAAqB,CAArB,IAA0B,KAAKnD,IAAL,GAAY,KAAKkD,KAAL,CAAWC,MAArD,EAA6D;AACzD,aAAKnD,IAAL,IAAasE,UAAb;AACH;;AACD,UAAI,KAAKpB,KAAL,CAAWF,IAAX,IAAmB,CAAnB,IAAwB,KAAKA,IAAL,GAAY,KAAKE,KAAL,CAAWF,IAAnD,EAAyD;AACrD,aAAKA,IAAL,IAAasB,UAAU,GAAG,KAAK1E,OAAL,CAAaI,IAAb,CAAkBiD,OAA/B,GAAyCtD,SAAS,CAACyC,MAAV,CAAiBG,YAAvE;AACH;AACJ,KAxBD,MAyBK;AACD,WAAKlC,uBAAL,CAA6BC,QAA7B,EAAuCC,CAAvC;AACH;AACJ;;AACDgE,EAAAA,IAAI,CAACC,OAAD,EAAU;AACVA,IAAAA,OAAO,CAACC,SAAR,CAAkB,KAAK5E,QAAL,CAAcM,CAAhC,EAAmC,KAAKN,QAAL,CAAcO,CAAjD;AACAoE,IAAAA,OAAO,CAACE,SAAR;AACAF,IAAAA,OAAO,CAACG,GAAR,CAAY,CAAZ,EAAe,CAAf,EAAkB,KAAK3E,IAAvB,EAA6B,CAA7B,EAAgCqB,IAAI,CAACC,EAAL,GAAU,CAA1C,EAA6C,KAA7C;AACAkD,IAAAA,OAAO,CAACI,SAAR;AACAJ,IAAAA,OAAO,CAACK,SAAR,GAAoBzF,eAAe,CAAC,KAAKgE,KAAN,EAAa,KAAKN,OAAlB,CAAnC;AACA0B,IAAAA,OAAO,CAACM,IAAR;AACH;;AACDC,EAAAA,MAAM,GAAG;AACL,UAAMrC,eAAe,GAAG,KAAKA,eAA7B;AACA,SAAK7C,QAAL,GACI6C,eAAe,IAAIrD,aAAa,CAACqD,eAAD,EAAkB,KAAK/C,SAAL,CAAeM,MAAf,CAAsBD,IAAxC,EAA8CnB,MAAM,CAACmD,MAArD,CAAhC,GACMU,eADN,GAEM,KAAK5C,aAAL,EAHV;AAIH;;AAjJyB","sourcesContent":["import { Vector, calcPositionOrRandomFromSize, calcPositionOrRandomFromSizeRanged, getDistance, getDistances, getRandom, getRangeValue, getStyleFromRgb, isPointInside, rangeColorToRgb, } from \"tsparticles-engine\";\nimport { Absorber } from \"./Options/Classes/Absorber\";\nexport class AbsorberInstance {\n    constructor(absorbers, container, options, position) {\n        this.absorbers = absorbers;\n        this.container = container;\n        this._calcPosition = () => {\n            const exactPosition = calcPositionOrRandomFromSizeRanged({\n                size: this.container.canvas.size,\n                position: this.options.position,\n            });\n            return Vector.create(exactPosition.x, exactPosition.y);\n        };\n        this._updateParticlePosition = (particle, v) => {\n            if (particle.destroyed) {\n                return;\n            }\n            const container = this.container, canvasSize = container.canvas.size;\n            if (particle.needsNewPosition) {\n                const newPosition = calcPositionOrRandomFromSize({ size: canvasSize });\n                particle.position.setTo(newPosition);\n                particle.velocity.setTo(particle.initialVelocity);\n                particle.absorberOrbit = undefined;\n                particle.needsNewPosition = false;\n            }\n            if (this.options.orbits) {\n                if (particle.absorberOrbit === undefined) {\n                    particle.absorberOrbit = Vector.create(0, 0);\n                    particle.absorberOrbit.length = getDistance(particle.getPosition(), this.position);\n                    particle.absorberOrbit.angle = getRandom() * Math.PI * 2;\n                }\n                if (particle.absorberOrbit.length <= this.size && !this.options.destroy) {\n                    const minSize = Math.min(canvasSize.width, canvasSize.height);\n                    particle.absorberOrbit.length = minSize * (1 + (getRandom() * 0.2 - 0.1));\n                }\n                if (particle.absorberOrbitDirection === undefined) {\n                    particle.absorberOrbitDirection =\n                        particle.velocity.x >= 0 ? \"clockwise\" : \"counter-clockwise\";\n                }\n                const orbitRadius = particle.absorberOrbit.length, orbitAngle = particle.absorberOrbit.angle, orbitDirection = particle.absorberOrbitDirection;\n                particle.velocity.setTo(Vector.origin);\n                const updateFunc = {\n                    x: orbitDirection === \"clockwise\" ? Math.cos : Math.sin,\n                    y: orbitDirection === \"clockwise\" ? Math.sin : Math.cos,\n                };\n                particle.position.x = this.position.x + orbitRadius * updateFunc.x(orbitAngle);\n                particle.position.y = this.position.y + orbitRadius * updateFunc.y(orbitAngle);\n                particle.absorberOrbit.length -= v.length;\n                particle.absorberOrbit.angle +=\n                    (((particle.retina.moveSpeed ?? 0) * container.retina.pixelRatio) / 100) *\n                        container.retina.reduceFactor;\n            }\n            else {\n                const addV = Vector.origin;\n                addV.length = v.length;\n                addV.angle = v.angle;\n                particle.velocity.addTo(addV);\n            }\n        };\n        this.initialPosition = position ? Vector.create(position.x, position.y) : undefined;\n        if (options instanceof Absorber) {\n            this.options = options;\n        }\n        else {\n            this.options = new Absorber();\n            this.options.load(options);\n        }\n        this.dragging = false;\n        this.name = this.options.name;\n        this.opacity = this.options.opacity;\n        this.size = getRangeValue(this.options.size.value) * container.retina.pixelRatio;\n        this.mass = this.size * this.options.size.density * container.retina.reduceFactor;\n        const limit = this.options.size.limit;\n        this.limit = {\n            radius: limit.radius * container.retina.pixelRatio * container.retina.reduceFactor,\n            mass: limit.mass,\n        };\n        this.color = rangeColorToRgb(this.options.color) ?? {\n            b: 0,\n            g: 0,\n            r: 0,\n        };\n        this.position = this.initialPosition?.copy() ?? this._calcPosition();\n    }\n    attract(particle) {\n        const container = this.container, options = this.options;\n        if (options.draggable) {\n            const mouse = container.interactivity.mouse;\n            if (mouse.clicking && mouse.downPosition) {\n                const mouseDist = getDistance(this.position, mouse.downPosition);\n                if (mouseDist <= this.size) {\n                    this.dragging = true;\n                }\n            }\n            else {\n                this.dragging = false;\n            }\n            if (this.dragging && mouse.position) {\n                this.position.x = mouse.position.x;\n                this.position.y = mouse.position.y;\n            }\n        }\n        const pos = particle.getPosition(), { dx, dy, distance } = getDistances(this.position, pos), v = Vector.create(dx, dy);\n        v.length = (this.mass / Math.pow(distance, 2)) * container.retina.reduceFactor;\n        if (distance < this.size + particle.getRadius()) {\n            const sizeFactor = particle.getRadius() * 0.033 * container.retina.pixelRatio;\n            if ((this.size > particle.getRadius() && distance < this.size - particle.getRadius()) ||\n                (particle.absorberOrbit !== undefined && particle.absorberOrbit.length < 0)) {\n                if (options.destroy) {\n                    particle.destroy();\n                }\n                else {\n                    particle.needsNewPosition = true;\n                    this._updateParticlePosition(particle, v);\n                }\n            }\n            else {\n                if (options.destroy) {\n                    particle.size.value -= sizeFactor;\n                }\n                this._updateParticlePosition(particle, v);\n            }\n            if (this.limit.radius <= 0 || this.size < this.limit.radius) {\n                this.size += sizeFactor;\n            }\n            if (this.limit.mass <= 0 || this.mass < this.limit.mass) {\n                this.mass += sizeFactor * this.options.size.density * container.retina.reduceFactor;\n            }\n        }\n        else {\n            this._updateParticlePosition(particle, v);\n        }\n    }\n    draw(context) {\n        context.translate(this.position.x, this.position.y);\n        context.beginPath();\n        context.arc(0, 0, this.size, 0, Math.PI * 2, false);\n        context.closePath();\n        context.fillStyle = getStyleFromRgb(this.color, this.opacity);\n        context.fill();\n    }\n    resize() {\n        const initialPosition = this.initialPosition;\n        this.position =\n            initialPosition && isPointInside(initialPosition, this.container.canvas.size, Vector.origin)\n                ? initialPosition\n                : this._calcPosition();\n    }\n}\n"]},"metadata":{},"sourceType":"module"}